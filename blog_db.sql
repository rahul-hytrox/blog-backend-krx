-- phpMyAdmin SQL Dump
-- version 5.2.1
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1
-- Generation Time: Feb 26, 2026 at 01:49 PM
-- Server version: 10.4.32-MariaDB
-- PHP Version: 8.1.25

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `blog_db`
--

-- --------------------------------------------------------

--
-- Table structure for table `admins`
--

CREATE TABLE `admins` (
  `id` int(11) NOT NULL,
  `username` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

-- --------------------------------------------------------

--
-- Table structure for table `blogs`
--

CREATE TABLE `blogs` (
  `id` int(11) NOT NULL,
  `title` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `image_url` varchar(255) DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `updated_at` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp(),
  `title_ar` varchar(255) DEFAULT NULL,
  `content_ar` text DEFAULT NULL,
  `title_es` varchar(255) DEFAULT NULL,
  `content_es` text DEFAULT NULL,
  `title_fr` varchar(255) DEFAULT NULL,
  `content_fr` text DEFAULT NULL,
  `title_de` varchar(255) DEFAULT NULL,
  `content_de` text DEFAULT NULL,
  `title_pt` varchar(255) DEFAULT NULL,
  `content_pt` text DEFAULT NULL,
  `title_ja` varchar(255) DEFAULT NULL,
  `content_ja` text DEFAULT NULL,
  `title_ru` varchar(255) DEFAULT NULL,
  `content_ru` text DEFAULT NULL,
  `title_nl` varchar(255) DEFAULT NULL,
  `content_nl` text DEFAULT NULL,
  `title_sv` varchar(255) DEFAULT NULL,
  `content_sv` text DEFAULT NULL,
  `title_tr` varchar(255) DEFAULT NULL,
  `content_tr` text DEFAULT NULL,
  `title_uk` varchar(255) DEFAULT NULL,
  `content_uk` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Dumping data for table `blogs`
--

INSERT INTO `blogs` (`id`, `title`, `content`, `image_url`, `created_at`, `updated_at`, `title_ar`, `content_ar`, `title_es`, `content_es`, `title_fr`, `content_fr`, `title_de`, `content_de`, `title_pt`, `content_pt`, `title_ja`, `content_ja`, `title_ru`, `content_ru`, `title_nl`, `content_nl`, `title_sv`, `content_sv`, `title_tr`, `content_tr`, `title_uk`, `content_uk`) VALUES
(1, 'Understanding the JavaScript Event Loop: The Complete Guide for Beginners and Pros', '<p>The&nbsp;Angular&nbsp;team&nbsp;has&nbsp;done&nbsp;it&nbsp;again.&nbsp;With&nbsp;the&nbsp;release&nbsp;of&nbsp;Angular&nbsp;v21.1.4,&nbsp;the&nbsp;framework&nbsp;isn&#39;t&nbsp;just&nbsp;getting&nbsp;incremental&nbsp;improvements;&nbsp;it&#39;s&nbsp;solidifying&nbsp;a&nbsp;major&nbsp;shift&nbsp;in&nbsp;how&nbsp;we&nbsp;build&nbsp;web&nbsp;applications.&nbsp;This&nbsp;version&nbsp;builds&nbsp;upon&nbsp;the&nbsp;foundational&nbsp;changes&nbsp;introduced&nbsp;in&nbsp;Angular&nbsp;21,&nbsp;moving&nbsp;experimental&nbsp;features&nbsp;toward&nbsp;stability&nbsp;and&nbsp;making&nbsp;the&nbsp;developer&nbsp;experience&nbsp;smoother&nbsp;than&nbsp;ever.</p><p>But&nbsp;why&nbsp;should&nbsp;you&nbsp;upgrade?&nbsp;And&nbsp;what&nbsp;makes&nbsp;this&nbsp;update&nbsp;a&nbsp;potential&nbsp;<strong>game-changer</strong>&nbsp;for&nbsp;your&nbsp;development&nbsp;workflow?&nbsp;Let&#39;s&nbsp;dive&nbsp;into&nbsp;the&nbsp;new&nbsp;updates&nbsp;and&nbsp;explore&nbsp;how&nbsp;they&nbsp;redefine&nbsp;productivity&nbsp;and&nbsp;performance.</p><p></p><h2>Why&nbsp;Use&nbsp;Angular&nbsp;v21.1.4?</h2><h2></h2><p>Angular&nbsp;has&nbsp;been&nbsp;on&nbsp;a&nbsp;transformative&nbsp;journey&nbsp;from&nbsp;a&nbsp;module-heavy,&nbsp;zone.js-dependent&nbsp;framework&nbsp;to&nbsp;a&nbsp;modern,&nbsp;reactive,&nbsp;and&nbsp;finely-tuned&nbsp;platform&nbsp;.&nbsp;Version&nbsp;21.1.4&nbsp;represents&nbsp;the&nbsp;culmination&nbsp;of&nbsp;this&nbsp;evolution.&nbsp;It’s&nbsp;about&nbsp;<strong>future-proofing&nbsp;your&nbsp;applications</strong>.&nbsp;By&nbsp;adopting&nbsp;this&nbsp;version,&nbsp;you&#39;re&nbsp;not&nbsp;just&nbsp;getting&nbsp;the&nbsp;latest&nbsp;features;&nbsp;you&#39;re&nbsp;buying&nbsp;into&nbsp;a&nbsp;philosophy&nbsp;of&nbsp;cleaner&nbsp;code,&nbsp;better&nbsp;performance,&nbsp;and&nbsp;a&nbsp;more&nbsp;intuitive&nbsp;development&nbsp;process.</p><p></p><h2>What’s&nbsp;New&nbsp;in&nbsp;v21.1.4?&nbsp;The&nbsp;Game-Changers&nbsp;for&nbsp;Developers</h2><h2></h2><p>While&nbsp;the&nbsp;&quot;point&quot;&nbsp;release&nbsp;focuses&nbsp;on&nbsp;stability&nbsp;and&nbsp;refinement,&nbsp;it&nbsp;rides&nbsp;on&nbsp;the&nbsp;coattails&nbsp;of&nbsp;the&nbsp;monumental&nbsp;v21&nbsp;update.&nbsp;Here&nbsp;are&nbsp;the&nbsp;features&nbsp;that&nbsp;are&nbsp;truly&nbsp;game-changing&nbsp;for&nbsp;developers.</p><h3></h3><h3>1.&nbsp;The&nbsp;Final&nbsp;Farewell&nbsp;to&nbsp;<code>zone.js</code>&nbsp;(Zoneless&nbsp;by&nbsp;Default)</h3><p>For&nbsp;years,&nbsp;Angular&nbsp;relied&nbsp;on&nbsp;<code>zone.js</code>&nbsp;to&nbsp;track&nbsp;changes&nbsp;and&nbsp;trigger&nbsp;updates.&nbsp;It&nbsp;worked&nbsp;like&nbsp;magic,&nbsp;but&nbsp;that&nbsp;magic&nbsp;came&nbsp;at&nbsp;a&nbsp;cost:&nbsp;complexity&nbsp;and&nbsp;performance&nbsp;overhead.&nbsp;With&nbsp;Angular&nbsp;v21,&nbsp;new&nbsp;projects&nbsp;are&nbsp;now&nbsp;<strong>zoneless&nbsp;by&nbsp;default</strong>&nbsp;.</p><p></p><ul><li><strong>What&nbsp;it&nbsp;means:</strong>&nbsp;Angular&nbsp;now&nbsp;relies&nbsp;on&nbsp;its&nbsp;fine-grained&nbsp;reactivity&nbsp;system,&nbsp;<strong>Signals</strong>,&nbsp;to&nbsp;manage&nbsp;change&nbsp;detection.&nbsp;You&nbsp;get&nbsp;predictable,&nbsp;explicit&nbsp;updates&nbsp;without&nbsp;the&nbsp;&quot;magic&quot;&nbsp;of&nbsp;Zone.js&nbsp;patching&nbsp;browser&nbsp;APIs&nbsp;.</li><li><strong>The&nbsp;Game-Changer:</strong>&nbsp;This&nbsp;leads&nbsp;to&nbsp;<strong>smaller&nbsp;bundle&nbsp;sizes</strong>,&nbsp;<strong>faster&nbsp;rendering</strong>,&nbsp;and&nbsp;<strong>improved&nbsp;Core&nbsp;Web&nbsp;Vitals</strong>&nbsp;.&nbsp;Debugging&nbsp;becomes&nbsp;more&nbsp;straightforward&nbsp;because&nbsp;you&nbsp;control&nbsp;exactly&nbsp;when&nbsp;and&nbsp;how&nbsp;the&nbsp;UI&nbsp;updates.&nbsp;For&nbsp;existing&nbsp;apps,&nbsp;Angular&nbsp;provides&nbsp;migration&nbsp;tooling&nbsp;to&nbsp;help&nbsp;you&nbsp;make&nbsp;the&nbsp;leap&nbsp;.</li></ul><p></p><h3>2.&nbsp;Signal&nbsp;Forms:&nbsp;A&nbsp;New&nbsp;Reactive&nbsp;Paradigm</h3><p>If&nbsp;you&#39;ve&nbsp;ever&nbsp;struggled&nbsp;with&nbsp;the&nbsp;verbosity&nbsp;of&nbsp;Reactive&nbsp;Forms—the&nbsp;<code>FormBuilder</code>,&nbsp;the&nbsp;subscriptions,&nbsp;the&nbsp;complex&nbsp;type&nbsp;safety—then&nbsp;this&nbsp;is&nbsp;for&nbsp;you.&nbsp;Angular&nbsp;21&nbsp;introduces&nbsp;<strong>Signal&nbsp;Forms</strong>&nbsp;(currently&nbsp;experimental),&nbsp;a&nbsp;brand-new&nbsp;way&nbsp;to&nbsp;handle&nbsp;form&nbsp;state&nbsp;.</p><p></p><pre data-language=\"javascript\">\r\nimport { signal } from &#39;@angular/core&#39;;\r\nimport { form, Field } from &#39;@angular/forms/signals&#39;;\r\n\r\n@Component({\r\n  selector: &#39;app-login&#39;,\r\n  imports: [Field],\r\n  template: `\r\n    &lt;input [field]=&quot;loginForm.email&quot; type=&quot;email&quot; /&gt;\r\n    &lt;input [field]=&quot;loginForm.password&quot; type=&quot;password&quot; /&gt;\r\n  `\r\n})\r\nexport class LoginComponent {\r\n  private loginModel = signal({ email: &#39;&#39;, password: &#39;&#39; });\r\n  loginForm = form(this.loginModel);\r\n}\r\n</pre><p></p><ul><li><strong>The&nbsp;Game-Changer:</strong>&nbsp;Say&nbsp;goodbye&nbsp;to&nbsp;<code>.valueChanges</code>&nbsp;subscriptions&nbsp;and&nbsp;manual&nbsp;<code>patchValue</code>&nbsp;calls.&nbsp;Signal&nbsp;Forms&nbsp;offer&nbsp;<strong>automatic&nbsp;two-way&nbsp;binding</strong>,&nbsp;<strong>complete&nbsp;type&nbsp;safety</strong>&nbsp;(no&nbsp;more&nbsp;<code>null</code>&nbsp;issues),&nbsp;and&nbsp;<strong>centralized,&nbsp;schema-based&nbsp;validation</strong>&nbsp;.&nbsp;It&nbsp;drastically&nbsp;reduces&nbsp;boilerplate&nbsp;and&nbsp;makes&nbsp;forms&nbsp;a&nbsp;natural&nbsp;part&nbsp;of&nbsp;your&nbsp;reactive,&nbsp;signal-based&nbsp;architecture.</li><li></li></ul><h3>3.&nbsp;Angular&nbsp;Aria:&nbsp;First-Class&nbsp;Accessibility</h3><p>Accessibility&nbsp;(a11y)&nbsp;is&nbsp;often&nbsp;an&nbsp;afterthought,&nbsp;but&nbsp;not&nbsp;anymore.&nbsp;Angular&nbsp;21&nbsp;ships&nbsp;with&nbsp;a&nbsp;developer&nbsp;preview&nbsp;of&nbsp;<strong>Angular&nbsp;Aria</strong>,&nbsp;a&nbsp;library&nbsp;providing&nbsp;headless,&nbsp;accessible&nbsp;UI&nbsp;primitives&nbsp;.</p><ul><li><strong>What&nbsp;it&nbsp;is:</strong>&nbsp;A&nbsp;set&nbsp;of&nbsp;un-styled&nbsp;components&nbsp;(Accordion,&nbsp;Tabs,&nbsp;Combobox,&nbsp;etc.)&nbsp;that&nbsp;conform&nbsp;to&nbsp;WAI-ARIA&nbsp;standards.&nbsp;They&nbsp;handle&nbsp;all&nbsp;the&nbsp;complex&nbsp;keyboard&nbsp;interactions&nbsp;and&nbsp;semantic&nbsp;roles&nbsp;for&nbsp;you&nbsp;.</li><li><strong>The&nbsp;Game-Changer:</strong>&nbsp;You&nbsp;can&nbsp;now&nbsp;build&nbsp;fully&nbsp;accessible&nbsp;design&nbsp;systems&nbsp;without&nbsp;needing&nbsp;to&nbsp;be&nbsp;an&nbsp;ARIA&nbsp;expert.&nbsp;By&nbsp;leveraging&nbsp;these&nbsp;signal-powered&nbsp;primitives,&nbsp;you&nbsp;ensure&nbsp;your&nbsp;applications&nbsp;are&nbsp;inclusive&nbsp;by&nbsp;default,&nbsp;saving&nbsp;countless&nbsp;hours&nbsp;of&nbsp;manual&nbsp;auditing&nbsp;and&nbsp;fixing&nbsp;.</li></ul><p></p><h3>4.&nbsp;Angular&nbsp;MCP&nbsp;Server:&nbsp;AI-Native&nbsp;Development</h3><p>Perhaps&nbsp;the&nbsp;most&nbsp;forward-looking&nbsp;feature&nbsp;is&nbsp;the&nbsp;official&nbsp;<strong>Model&nbsp;Context&nbsp;Protocol&nbsp;(MCP)&nbsp;Server</strong>&nbsp;.</p><ul><li><strong>What&nbsp;it&nbsp;is:</strong>&nbsp;It’s&nbsp;a&nbsp;tool&nbsp;that&nbsp;allows&nbsp;AI&nbsp;agents&nbsp;(like&nbsp;your&nbsp;IDE’s&nbsp;assistant)&nbsp;to&nbsp;understand&nbsp;your&nbsp;Angular&nbsp;project&nbsp;structure,&nbsp;access&nbsp;documentation,&nbsp;and&nbsp;suggest&nbsp;best&nbsp;practices&nbsp;contextually.</li><li><strong>The&nbsp;Game-Changer:</strong>&nbsp;Imagine&nbsp;asking&nbsp;your&nbsp;editor,&nbsp;&quot;Why&nbsp;is&nbsp;this&nbsp;component&nbsp;re-rendering?&quot;&nbsp;or&nbsp;&quot;Update&nbsp;this&nbsp;code&nbsp;to&nbsp;use&nbsp;the&nbsp;new&nbsp;control&nbsp;flow&nbsp;syntax,&quot;&nbsp;and&nbsp;having&nbsp;it&nbsp;done&nbsp;instantly&nbsp;with&nbsp;Angular-aware&nbsp;intelligence.&nbsp;It&nbsp;includes&nbsp;an&nbsp;<code><strong>ai_tutor</strong></code>&nbsp;feature,&nbsp;making&nbsp;learning&nbsp;and&nbsp;debugging&nbsp;a&nbsp;conversation&nbsp;rather&nbsp;than&nbsp;a&nbsp;Google&nbsp;search&nbsp;.&nbsp;This&nbsp;isn&#39;t&nbsp;just&nbsp;a&nbsp;code&nbsp;generator;&nbsp;it&#39;s&nbsp;a&nbsp;context-aware&nbsp;pair&nbsp;programmer.</li></ul><p></p><h3>5.&nbsp;Vitest&nbsp;as&nbsp;the&nbsp;Default&nbsp;Test&nbsp;Runner</h3><p>Testing&nbsp;just&nbsp;got&nbsp;a&nbsp;massive&nbsp;speed&nbsp;boost.&nbsp;Angular&nbsp;v21&nbsp;now&nbsp;makes&nbsp;<strong>Vitest&nbsp;the&nbsp;default&nbsp;test&nbsp;runner</strong>&nbsp;for&nbsp;new&nbsp;projects&nbsp;.</p><ul><li><strong>The&nbsp;Game-Changer:</strong>&nbsp;Vitest&nbsp;is&nbsp;significantly&nbsp;faster&nbsp;than&nbsp;Karma,&nbsp;offers&nbsp;a&nbsp;modern&nbsp;API,&nbsp;and&nbsp;integrates&nbsp;perfectly&nbsp;with&nbsp;the&nbsp;ES&nbsp;Build-powered&nbsp;build&nbsp;system.&nbsp;Faster&nbsp;tests&nbsp;mean&nbsp;faster&nbsp;feedback&nbsp;loops,&nbsp;which&nbsp;is&nbsp;crucial&nbsp;for&nbsp;productivity.&nbsp;The&nbsp;Angular&nbsp;team&nbsp;even&nbsp;provides&nbsp;a&nbsp;migration&nbsp;schematic&nbsp;to&nbsp;help&nbsp;existing&nbsp;projects&nbsp;make&nbsp;the&nbsp;switch&nbsp;.</li></ul><p></p><h2>Summary:&nbsp;Why&nbsp;This&nbsp;Matters</h2><p>Angular&nbsp;v21.1.4&nbsp;isn&#39;t&nbsp;just&nbsp;another&nbsp;version&nbsp;bump;&nbsp;it&#39;s&nbsp;a&nbsp;statement&nbsp;of&nbsp;intent.&nbsp;It&#39;s&nbsp;about:</p><p></p><p></p><table style=\"border: 1px solid #000;\"><tbody><tr><td data-row=\"2\"><strong>Zoneless&nbsp;by&nbsp;Default</strong></td><td data-row=\"2\">Predictable&nbsp;performance,&nbsp;smaller&nbsp;bundles,&nbsp;simpler&nbsp;debugging.</td></tr><tr><td data-row=\"3\"><strong>Signal&nbsp;Forms</strong></td><td data-row=\"3\">Reactive,&nbsp;type-safe&nbsp;forms&nbsp;with&nbsp;zero&nbsp;boilerplate.</td></tr><tr><td data-row=\"4\"><strong>Angular&nbsp;Aria</strong></td><td data-row=\"4\">Build&nbsp;accessible&nbsp;apps&nbsp;effortlessly&nbsp;with&nbsp;framework-backed&nbsp;primitives.</td></tr><tr><td data-row=\"5\"><strong>MCP&nbsp;Server</strong></td><td data-row=\"5\">AI-powered&nbsp;development&nbsp;that&nbsp;truly&nbsp;understands&nbsp;your&nbsp;code.</td></tr><tr><td data-row=\"6\"><strong>Vitest</strong></td><td data-row=\"6\">Lightning-fast&nbsp;unit&nbsp;testing&nbsp;for&nbsp;a&nbsp;smoother&nbsp;developer&nbsp;experience.</td></tr></tbody></table><p></p><p>By&nbsp;upgrading,&nbsp;you&#39;re&nbsp;not&nbsp;just&nbsp;keeping&nbsp;up&nbsp;with&nbsp;the&nbsp;latest&nbsp;trends;&nbsp;you&#39;re&nbsp;equipping&nbsp;yourself&nbsp;with&nbsp;tools&nbsp;that&nbsp;make&nbsp;development&nbsp;faster,&nbsp;applications&nbsp;more&nbsp;performant,&nbsp;and&nbsp;your&nbsp;codebase&nbsp;more&nbsp;maintainable.&nbsp;The&nbsp;future&nbsp;of&nbsp;Angular&nbsp;is&nbsp;here—it’s&nbsp;zoneless,&nbsp;signal-driven,&nbsp;and&nbsp;smarter&nbsp;than&nbsp;ever.</p><p></p><h3>Ready&nbsp;to&nbsp;give&nbsp;it&nbsp;a&nbsp;try?&nbsp;Just&nbsp;run:</h3><p></p><pre data-language=\"plain\">\r\nnpm install -g @angular/cli@latest\r\nng new my-zoneless-app\r\n</pre><p></p>', '/uploads/1770987088254.png', '2026-02-13 12:51:28', '2026-02-23 08:26:28', 'فهم حلقة الأحداث في جافا سكريبت: الدليل الكامل للمبتدئين والمحترفين', '<p>جافا سكريبت في كل مكان من المواقع التفاعلية إلى تطبيقات جانب الخادم باستخدام Node.js. واحدة من أقوى الميزات (وغالباً ما يساء فهمها) في اللغة هي قدرتها على التعامل مع العديد من المهام في نفس الوقت على ما يبدو، على الرغم من كونها <strong>أحادية الخيط</strong>. كيف تفعل ذلك؟ السر هو <strong>حلقة الأحداث</strong>.</p><p></p><p><strong>في هذا الدليل، سنزيل الغموض عن حلقة الأحداث في جافا سكريبت. سوف تتعلم:</strong></p><ul><li>ما هي حلقة الأحداث ولماذا هي مهمة.</li><li>كيف تعمل مكدس الاستدعاءات، وواجهات برمجة تطبيقات الويب، وقوائم انتظار الاسترجاعات معاً.</li><li>الفرق بين <strong>المهام الصغيرة</strong> و<strong>المهام الكبيرة</strong>.</li><li>أمثلة من العالم الحقيقي تظهر حلقة الأحداث أثناء العمل.</li><li>المزالق الشائعة وكيفية تجنبها.</li></ul><p>في النهاية، سيكون لديك فهم قوي لجافا سكريبت غير المتزامن - وهو أمر ضروري لتصحيح الأخطاء، وكتابة كود فعال، والتفوق في المقابلات التقنية.</p><p></p><h2>1. بيئة تشغيل جافا سكريبت</h2><p>لفهم حلقة الأحداث، نحتاج أولاً إلى نظرة عامة على بيئة تشغيل جافا سكريبت (في المتصفح أو Node.js). المكونات الرئيسية هي:</p><ul><li><strong>الكومة</strong> – حيث يتم تخزين الكائنات في الذاكرة.</li><li><strong>مكدس الاستدعاءات</strong> – هيكل LIFO (آخر دخول أول خروج) يتتبع تنفيذ الوظائف.</li><li><strong>واجهات برمجة تطبيقات الويب / Node</strong> – ميزات يوفرها المتصفح مثل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>، وأحداث DOM، و<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>، أو وحدة <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> في Node.js. تعمل خارج الخيط الرئيسي.</li><li><strong>قائمة انتظار الاسترجاعات</strong> (تسمى أيضاً قائمة انتظار المهام) – تحتوي على استرجاعات من واجهات برمجة تطبيقات الويب الجاهزة للتنفيذ.</li><li><strong>قائمة انتظار المهام الصغيرة</strong> – قائمة انتظار خاصة للوعود، و<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong>، و<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>حلقة الأحداث</strong> – المنسق الذي ينقل الاسترجاعات من قوائم الانتظار إلى مكدس الاستدعاءات عندما يكون المكدس فارغاً.</li></ul><p></p><p></p><blockquote>? <strong>ملاحظة:</strong> محرك جافا سكريبت نفسه (مثل V8) <strong>لا</strong> يتضمن واجهات برمجة تطبيقات الويب أو حلقة الأحداث. يتم توفيرها بواسطة المتصفح أو بيئة Node.js.</blockquote><p></p><h2>2. مكدس الاستدعاءات – التنفيذ المتزامن</h2><p>مكدس الاستدعاءات هو المكان الذي يعمل فيه الكود الخاص بك سطراً بسطر. عندما تستدعي وظيفة، يتم دفعها إلى المكدس؛ عندما تعود الوظيفة، يتم إخراجها.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>خطوة بخطوة:</strong></p><ul><li>يتم دفع <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> إلى المكدس.</li><li>داخل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello، يتم استدعاء greet()</strong> ودفعها إلى المكدس.</li><li>ترجع <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong>، لذلك يتم إخراجها.</li><li>يتم دفع <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> وتنفيذها ثم إخراجها.</li><li>تنتهي <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> ويتم إخراجها.</li></ul><p>أصبح المكدس فارغاً الآن. بسيط، أليس كذلك؟ تنشأ المشاكل عندما نحاول القيام بشيء يستغرق وقتاً مثل طلب شبكة أو مؤقت. إذا انتظرنا بشكل متزامن، ستتجمد الصفحة بأكملها. هذا هو المكان الذي تأتي فيه واجهات برمجة التطبيقات غير المتزامنة.</p><p></p><h2>3. جافا سكريبت غير المتزامن – الخطوة إلى الخارج</h2><p>عندما تستدعي وظيفة غير متزامنة (مثل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> أو <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> أو مستمع الحدث)، فإنها لا تمنع المكدس. بدلاً من ذلك، يتولى المتصفح أو Node.js المهمة.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>ما يحدث وراء الكواليس:</strong></p><ul><li>يتم تشغيل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> ويتم إخراجها.</li><li>يتم استدعاء <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. يتم تسليم استرجاعها إلى <strong>واجهة برمجة تطبيقات الويب</strong> (مؤقت في هذه الحالة). يبدأ المؤقت في العد التنازلي في الخلفية، <strong>خارج</strong> الخيط الرئيسي.</li><li>يتم تشغيل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> على الفور.</li><li>بعد حوالي 1000 مللي ثانية، تنقل واجهة برمجة تطبيقات الويب الاسترجاع إلى <strong>قائمة انتظار الاسترجاعات</strong>.</li><li>تتحقق <strong>حلقة الأحداث</strong> باستمرار: <em>\"هل مكدس الاستدعاءات فارغ؟\"</em> عندما يكون فارغاً، تأخذ أول استرجاع من قائمة الانتظار وتدفعه إلى المكدس للتنفيذ.</li><li>يتم تسجيل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>حتى لو كان التأخير 0 مللي ثانية <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>، فإن الاسترجاع سيظل ينتظر في قائمة الانتظار حتى يصبح المكدس فارغاً. لهذا السبب يتم تسجيل <strong>&quot;End&quot;</strong> دائماً قبل <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. حلقة الأحداث – الحارس الأبدي</h2><p>لدى حلقة الأحداث مهمة واحدة بسيطة: <strong>مراقبة مكدس الاستدعاءات وقوائم انتظار الاسترجاعات</strong>. إذا كان المكدس فارغاً، تأخذ أول استرجاع في انتظار وتدفعه إلى المكدس.</p><p>لكن هناك مفاجأة - هناك في الواقع <strong>نوعان</strong> من قوائم الانتظار: <strong>المهام الكبيرة</strong> (أو مجرد \"مهام\") و<strong>المهام الصغيرة</strong>. تتعامل حلقة الأحداث معها بشكل مختلف.</p><p></p><h3>المهام الكبيرة (أو المهام)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>، <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>، <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js)، مهام الإدخال/الإخراج، عرض واجهة المستخدم.</li><li>كل تكرار لحلقة الأحداث يعالج <strong>مهمة كبيرة واحدة</strong> من قائمة انتظار الاسترجاعات.</li></ul><p></p><h3>المهام الصغيرة</h3><ul><li>الوعود (<strong class=\"ql-font-monospace\">then</strong>، <strong class=\"ql-font-monospace\">catch</strong>، <strong class=\"ql-font-monospace\">finally</strong>)، <strong class=\"ql-font-monospace\">async/await</strong>، <strong class=\"ql-font-monospace\">MutationObserver</strong>، <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>بعد <strong>كل</strong> مهمة كبيرة، تفرغ حلقة الأحداث <strong>قائمة انتظار المهام الصغيرة بالكامل</strong> قبل الانتقال إلى المهمة الكبيرة التالية أو العرض.</li></ul><p>نظام الأولوية هذا بالغ الأهمية. دعنا نراه أثناء العمل.</p><p></p><h2>5. المهام الصغيرة مقابل المهام الكبيرة – من يأتي أولاً؟</h2><p></p><p><strong>تأمل هذا الكود:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>الإخراج:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>شرح خطوة بخطوة:</strong></p><p>يتم تشغيل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong>، يفرغ المكدس.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – يتم تسليم الاسترجاع إلى واجهة برمجة تطبيقات الويب (مؤقت بـ 0 مللي ثانية). بعد 0 مللي ثانية، ينتقل إلى <strong>قائمة انتظار المهام الكبيرة</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – استرجاع <code>then</code> هو <strong>مهمة صغيرة</strong>. يتم وضعه في قائمة انتظار المهام الصغيرة.</p><p>يتم تشغيل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> على الفور.</p><p>أصبح مكدس الاستدعاءات فارغاً الآن.</p><p><strong>نقطة تفتيش المهام الصغيرة:</strong> قبل أخذ أي مهمة كبيرة، تفرغ حلقة الأحداث قائمة انتظار المهام الصغيرة. لذلك يتم تشغيل <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span>، ثم يقوم <code>then</code> الثاني بجدولة مهمة صغيرة أخرى، والتي يتم تشغيلها أيضاً على الفور. يتم تسجيل <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span>.</p><p>قائمة انتظار المهام الصغيرة فارغة. الآن تختار حلقة الأحداث المهمة الكبيرة التالية من قائمة الانتظار – استرجاع <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. يتم تسجيل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</p><p>هذا يشرح لماذا يمكن للوعود \"القفز إلى الأمام\" قبل المؤقتات، حتى لو كان تأخير المؤقت صفراً.</p><p></p><h2>6. أمثلة عملية توضح حلقة الأحداث</h2><h3>مثال 1: خلط المؤقتات والوعود</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// الإخراج: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>مثال 2: المهام الصغيرة المتكررة</h3><p>ماذا يحدث إذا استمررت في إضافة مهام صغيرة داخل مهمة صغيرة؟</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // يخطط لمهمة صغيرة أخرى\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>سيؤدي هذا إلى تسجيل <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> إلى أجل غير مسمى، ولن يتم تشغيل استرجاع <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> <strong>أبداً</strong> لأن قائمة انتظار المهام الصغيرة لا تفرغ أبداً. هذا يمكن أن يجوع حلقة الأحداث – خطر حقيقي إذا لم تكن حريصاً.</p><p></p><h3>مثال 3: حلقة الأحداث وعرض واجهة المستخدم (المتصفح)</h3><p>في المتصفحات، يحدث العرض (الرسم) بعد المهام الصغيرة وقبل المهمة الكبيرة التالية. لهذا السبب يمكنك رؤية تعطيل التخطيط إذا قمت بتعديل DOM بشكل متكرر داخل المهام الصغيرة.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // هذا الاسترجاع هو مهمة كبيرة\r\n  Promise.resolve().then(() =&gt; {\r\n    // هذه المهمة الصغيرة تعمل قبل العرض التالي\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>عند النقر على الزر، الترتيب هو:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (مهمة كبيرة).</li><li>جميع المهام الصغيرة (استرجاع <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>).</li><li>ثم قد يقوم المتصفح بالعرض.</li></ul><p></p><h2>7. المزالق الشائعة وكيفية تجنبها</h2><h3>منع حلقة الأحداث</h3><p>الكود المتزامن طويل الأمد (مثل الحلقات الثقيلة، الحسابات المعقدة) يمنع حلقة الأحداث من معالجة المهام الأخرى. تتجمد واجهة المستخدم الخاصة بك، وتتأخر الاسترجاعات الأخرى.</p><p><strong>الحل:</strong> قسم العمل الثقيل إلى أجزاء أصغر باستخدام <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>، أو انقله إلى Web Worker (المتصفح) / خيوط عاملة (Node.js).</p><h3></h3><h3>نسيان أولوية المهام الصغيرة</h3><p>افتراض أن <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> سيعمل فوراً بعد الكود الآخر يمكن أن يؤدي إلى حالات سباق.</p><p><strong>الحل:</strong> افهم قائمة انتظار المهام الصغيرة. استخدم <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> أو <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> عندما تحتاج إلى التأجيل ولكن لا تزال تعمل قبل الإدخال/الإخراج.</p><h3></h3><h3>حلقات المهام الصغيرة اللانهائية</h3><p>كما هو موضح في المثال 2، يمكن أن تؤدي إضافة المهام الصغيرة بشكل متكرر إلى تجويع المهام الكبيرة وأحداث العرض.</p><p><strong>الحل:</strong> تجنب التكرار غير المحدود في المهام الصغيرة. استخدم مهمة كبيرة (مثل <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) للعمل المؤجل طويل الأمد.</p><h3></h3><h3>خلط دواخل Async/Await</h3><p>وظائف <strong>async</strong> هي مجرد سكر نحوي فوق الوعود. كل <strong>await</strong> ينشئ استمرار مهمة صغيرة. معرفة هذا يساعدك على توقع ترتيب التنفيذ.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // حدود مهمة صغيرة\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// الإخراج: 1, 3, 2\r\n</pre><p></p><h2>8. الخاتمة</h2><p>حلقة الأحداث هي نبض قلب جافا سكريبت. تسمح للغة أحادية الخيط بالتعامل مع العمليات غير المتزامنة بكفاءة، مما يحافظ على استجابة التطبيقات. من خلال فهم التفاعل بين مكدس الاستدعاءات، وواجهات برمجة تطبيقات الويب، وقائمة انتظار المهام الكبيرة، وقائمة انتظار المهام الصغيرة، يمكنك كتابة كود متوقع وعالي الأداء.</p><p><strong>الوجبات الرئيسية:</strong></p><ul><li>تعمل جافا سكريبت بشكل متزامن على مكدس الاستدعاءات.</li><li>تفوض واجهات برمجة التطبيقات غير المتزامنة العمل إلى البيئة (المتصفح/Node).</li><li>عندما يكون المكدس فارغاً، تنقل حلقة الأحداث الاسترجاعات من قوائم الانتظار إلى المكدس.</li><li><strong>المهام الصغيرة</strong> (الوعود، <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) لها أولوية أعلى من <strong>المهام الكبيرة</strong> (المؤقتات، الإدخال/الإخراج).</li><li>تعالج حلقة الأحداث جميع المهام الصغيرة قبل المهمة الكبيرة التالية أو العرض.</li></ul><p>إتقان حلقة الأحداث ليس مجرد موضوع مقابلة - إنه ضروري لتصحيح الأخطاء، وتجنب اختناقات الأداء، وفهم كيفية عمل جافا سكريبت حقاً تحت الغطاء.</p>', 'Entendiendo el bucle de eventos de JavaScript: La guía completa para principiantes y profesionales', '<p>JavaScript está en todas partes, desde sitios web interactivos hasta aplicaciones del lado del servidor con Node.js. Una de las características más poderosas (y a menudo malinterpretadas) del lenguaje es su capacidad para manejar muchas tareas aparentemente al mismo tiempo, a pesar de ser <strong>de un solo hilo</strong>. ¿Cómo lo logra? El secreto es el <strong>bucle de eventos</strong>.</p><p></p><p><strong>En esta guía, desmitificaremos el bucle de eventos de JavaScript. Aprenderás:</strong></p><ul><li>Qué es el bucle de eventos y por qué es importante.</li><li>Cómo funcionan juntos la pila de llamadas, las API web y las colas de devoluciones de llamada.</li><li>La diferencia entre <strong>microtareas</strong> y <strong>macrotareas</strong>.</li><li>Ejemplos del mundo real que muestran el bucle de eventos en acción.</li><li>Errores comunes y cómo evitarlos.</li></ul><p>Al final, tendrás un sólido conocimiento de JavaScript asíncrono, esencial para depurar, escribir código eficiente y sobresalir en entrevistas técnicas.</p><p></p><h2>1. El entorno de ejecución de JavaScript</h2><p>Para entender el bucle de eventos, primero necesitamos una vista general del entorno de ejecución de JavaScript (en un navegador o Node.js). Los componentes principales son:</p><ul><li><strong>Montón (Heap)</strong> – Donde se almacenan los objetos en memoria.</li><li><strong>Pila de llamadas (Call Stack)</strong> – Una estructura LIFO (último en entrar, primero en salir) que rastrea la ejecución de funciones.</li><li><strong>API web / API de Node</strong> – Características proporcionadas por el navegador como <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, eventos del DOM, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>, o el módulo <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> de Node.js. Se ejecutan fuera del hilo principal.</li><li><strong>Cola de devoluciones de llamada</strong> (también llamada Cola de tareas) – Contiene las devoluciones de llamada de las API web que están listas para ejecutarse.</li><li><strong>Cola de microtareas</strong> – Una cola especial para promesas, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> y <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Bucle de eventos</strong> – El orquestador que mueve las devoluciones de llamada de las colas a la pila de llamadas cuando la pila está vacía.</li></ul><p></p><p></p><blockquote>? <strong>Nota:</strong> El motor de JavaScript en sí mismo (como V8) <strong>no</strong> incluye las API web ni el bucle de eventos. Son proporcionados por el navegador o el entorno Node.js.</blockquote><p></p><h2>2. La pila de llamadas – Ejecución síncrona</h2><p>La pila de llamadas es donde se ejecuta tu código línea por línea. Cuando llamas a una función, se coloca en la pila; cuando la función retorna, se elimina de la pila.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Paso a paso:</strong></p><ul><li>Se coloca <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> en la pila.</li><li>Dentro de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong>, se llama a <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> y se coloca en la pila.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> retorna, por lo que se elimina de la pila.</li><li>Se coloca <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong>, se ejecuta y luego se elimina.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> termina y se elimina.</li></ul><p>La pila ahora está vacía. Sencillo, ¿verdad? Los problemas surgen cuando intentamos hacer algo que lleva tiempo, como una solicitud de red o un temporizador. Si esperamos de forma síncrona, toda la página se congelaría. Ahí es donde entran las API asíncronas.</p><p></p><h2>3. JavaScript asíncrono – Salir del paso</h2><p>Cuando llamas a una función asíncrona (por ejemplo, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> o un listener de eventos), no bloquea la pila. En cambio, el navegador o Node.js se hace cargo.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Lo que sucede entre bastidores:</strong></p><ul><li>Se ejecuta <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> y se elimina.</li><li>Se llama a <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. Su devolución de llamada se entrega a la <strong>API web</strong> (un temporizador en este caso). El temporizador comienza a contar en segundo plano, <strong>fuera</strong> del hilo principal.</li><li>Se ejecuta <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> inmediatamente.</li><li>Después de aproximadamente 1000 ms, la API web mueve la devolución de llamada a la <strong>cola de devoluciones de llamada</strong>.</li><li>El <strong>bucle de eventos</strong> comprueba constantemente: <em>\"¿Está vacía la pila de llamadas?\"</em> Cuando lo está, toma la primera devolución de llamada de la cola y la coloca en la pila para su ejecución.</li><li>Se registra <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Incluso si el retraso fuera 0 ms <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, la devolución de llamada aún esperaría en la cola hasta que la pila esté vacía. Por eso <strong>&quot;End&quot;</strong> siempre se registra antes que <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. El bucle de eventos – El guardián eterno</h2><p>El bucle de eventos tiene un trabajo simple: <strong>monitorear la pila de llamadas y las colas de devoluciones de llamada</strong>. Si la pila está vacía, toma la primera devolución de llamada en espera y la coloca en la pila.</p><p>Pero hay un detalle: en realidad existen <strong>dos</strong> tipos de colas: <strong>macrotareas</strong> (o simplemente \"tareas\") y <strong>microtareas</strong>. El bucle de eventos las maneja de manera diferente.</p><p></p><h3>Macrotareas (o Tareas)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), tareas de E/S, renderizado de UI.</li><li>Cada iteración del bucle de eventos procesa <strong>una</strong> macrotarea de la cola de devoluciones de llamada.</li></ul><p></p><h3>Microtareas</h3><ul><li>Promesas (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Después de <strong>cada</strong> macrotarea, el bucle de eventos vacía <strong>toda la cola de microtareas</strong> antes de pasar a la siguiente macrotarea o al renderizado.</li></ul><p>Este sistema de prioridad es crucial. Veámoslo en acción.</p><p></p><h2>5. Microtareas vs Macrotareas – ¿Quién va primero?</h2><p></p><p><strong>Considera este código:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Salida:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Explicación paso a paso:</strong></p><p>Se ejecuta <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong>, la pila se vacía.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – la devolución de llamada se entrega a la API web (temporizador con 0 ms). Después de 0 ms, se mueve a la <strong>cola de macrotareas</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – la devolución de llamada <code>then</code> es una <strong>microtarea</strong>. Se coloca en la cola de microtareas.</p><p>Se ejecuta <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> inmediatamente.</p><p>La pila de llamadas ahora está vacía.</p><p><strong>Punto de control de microtareas:</strong> Antes de tomar cualquier macrotarea, el bucle de eventos vacía la cola de microtareas. Así que se ejecuta <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span>, luego el segundo <code>then</code> programa otra microtarea, que también se ejecuta inmediatamente. Se registra <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span>.</p><p>La cola de microtareas está vacía. Ahora el bucle de eventos toma la siguiente macrotarea de la cola – la devolución de llamada de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. Se registra <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</p><p>Esto explica por qué las promesas pueden \"adelantarse\" a los temporizadores, incluso si el retraso del temporizador es cero.</p><p></p><h2>6. Ejemplos prácticos que aclaran el bucle de eventos</h2><h3>Ejemplo 1: Temporizadores y promesas mezclados</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Salida: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Ejemplo 2: Microtareas recursivas</h3><p>¿Qué sucede si sigues añadiendo microtareas dentro de una microtarea?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // programa otra microtarea\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Esto registrará <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> indefinidamente, y la devolución de llamada de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> <strong>nunca</strong> se ejecutará porque la cola de microtareas nunca se vacía. Esto puede hambrear el bucle de eventos – un peligro real si no tienes cuidado.</p><p></p><h3>Ejemplo 3: Bucle de eventos y renderizado de UI (navegador)</h3><p>En los navegadores, el renderizado (pintado) ocurre después de las microtareas y antes de la siguiente macrotarea. Por eso puedes ver problemas de layout si modificas repetidamente el DOM dentro de microtareas.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Esta devolución de llamada es una macrotarea\r\n  Promise.resolve().then(() =&gt; {\r\n    // Esta microtarea se ejecuta antes del próximo renderizado\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>Cuando se hace clic en el botón, el orden es:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (macrotarea).</li><li>Todas las microtareas (la devolución de llamada de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>).</li><li>Luego el navegador puede renderizar.</li></ul><p></p><h2>7. Errores comunes y cómo evitarlos</h2><h3>Bloquear el bucle de eventos</h3><p>El código síncrono de larga duración (por ejemplo, bucles pesados, cálculos complejos) impide que el bucle de eventos procese otras tareas. Tu UI se congela y otras devoluciones de llamada se retrasan.</p><p><strong>Solución:</strong> Divide el trabajo pesado en fragmentos más pequeños usando <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, o muévelo a un Web Worker (navegador) / hilos de trabajo (Node.js).</p><h3></h3><h3>Olvidar la prioridad de las microtareas</h3><p>Suponer que <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> se ejecutará inmediatamente después de otro código puede llevar a condiciones de carrera.</p><p><strong>Solución:</strong> Entiende la cola de microtareas. Usa <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> o <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> cuando necesites diferir pero aún así ejecutar antes de E/S.</p><h3></h3><h3>Bucles infinitos de microtareas</h3><p>Como se mostró en el Ejemplo 2, añadir microtareas de forma recursiva puede hambrear las macrotareas y los eventos de renderizado.</p><p><strong>Solución:</strong> Evita la recursión sin límite en microtareas. Usa una macrotarea (como <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) para trabajo diferido de larga duración.</p><h3></h3><h3>Mezclar internamente async/await</h3><p>Las funciones <strong>async</strong> son solo azúcar sintáctica sobre promesas. Cada <strong>await</strong> crea una continuación de microtarea. Saber esto te ayuda a predecir el orden de ejecución.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // límite de microtarea\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Salida: 1, 3, 2\r\n</pre><p></p><h2>8. Conclusión</h2><p>El bucle de eventos es el corazón de JavaScript. Permite que un lenguaje de un solo hilo maneje operaciones asíncronas de manera eficiente, manteniendo las aplicaciones receptivas. Al comprender la interacción entre la pila de llamadas, las API web, la cola de macrotareas y la cola de microtareas, puedes escribir código predecible y de alto rendimiento.</p><p><strong>Conclusiones clave:</strong></p><ul><li>JavaScript se ejecuta sincrónicamente en la pila de llamadas.</li><li>Las API asíncronas delegan el trabajo al entorno (navegador/Node).</li><li>Cuando la pila está vacía, el bucle de eventos mueve las devoluciones de llamada de las colas a la pila.</li><li><strong>Las microtareas</strong> (promesas, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) tienen mayor prioridad que <strong>las macrotareas</strong> (temporizadores, E/S).</li><li>El bucle de eventos procesa todas las microtareas antes de la siguiente macrotarea o renderizado.</li></ul><p>Dominar el bucle de eventos no es solo un tema de entrevista; es esencial para depurar, evitar cuellos de botella de rendimiento y entender realmente cómo funciona JavaScript bajo el capó.</p>', 'Comprendre la boucle d\'événements JavaScript : Le guide complet pour débutants et professionnels', '<p>JavaScript est partout, des sites web interactifs aux applications côté serveur avec Node.js. L\'une des fonctionnalités les plus puissantes (et souvent mal comprises) du langage est sa capacité à gérer de nombreuses tâches apparemment en même temps, bien qu\'il soit <strong>monothread</strong>. Comment fait-il ? Le secret réside dans la <strong>boucle d\'événements</strong>.</p><p></p><p><strong>Dans ce guide, nous allons démystifier la boucle d\'événements JavaScript. Vous apprendrez :</strong></p><ul><li>Ce qu\'est la boucle d\'événements et pourquoi elle est importante.</li><li>Comment la pile d\'appels, les API web et les files d\'attente de rappels fonctionnent ensemble.</li><li>La différence entre les <strong>microtâches</strong> et les <strong>macrotâches</strong>.</li><li>Des exemples concrets qui montrent la boucle d\'événements en action.</li><li>Les pièges courants et comment les éviter.</li></ul><p>À la fin, vous aurez une solide compréhension de JavaScript asynchrone, essentielle pour le débogage, l\'écriture de code efficace et la réussite des entretiens techniques.</p><p></p><h2>1. L\'environnement d\'exécution JavaScript</h2><p>Pour comprendre la boucle d\'événements, nous avons d\'abord besoin d\'une vue d\'ensemble de l\'environnement d\'exécution JavaScript (dans un navigateur ou Node.js). Les principaux composants sont :</p><ul><li><strong>Tas (Heap)</strong> – Où les objets sont stockés en mémoire.</li><li><strong>Pile d\'appels (Call Stack)</strong> – Une structure LIFO (dernier entré, premier sorti) qui suit l\'exécution des fonctions.</li><li><strong>API web / API Node</strong> – Fonctionnalités fournies par le navigateur comme <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, les événements DOM, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>, ou le module <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> de Node.js. Elles s\'exécutent en dehors du fil principal.</li><li><strong>File d\'attente des rappels</strong> (également appelée file d\'attente des tâches) – Contient les rappels des API web qui sont prêts à être exécutés.</li><li><strong>File d\'attente des microtâches</strong> – Une file d\'attente spéciale pour les promesses, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> et <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Boucle d\'événements</strong> – L\'orchestrateur qui déplace les rappels des files d\'attente vers la pile d\'appels lorsque la pile est vide.</li></ul><p></p><p></p><blockquote>? <strong>Remarque :</strong> Le moteur JavaScript lui-même (comme V8) <strong>n\'inclut pas</strong> les API web ni la boucle d\'événements. Ils sont fournis par le navigateur ou l\'environnement Node.js.</blockquote><p></p><h2>2. La pile d\'appels – Exécution synchrone</h2><p>La pile d\'appels est l\'endroit où votre code s\'exécute ligne par ligne. Lorsque vous appelez une fonction, elle est empilée ; lorsque la fonction retourne, elle est dépilée.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Étape par étape :</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> est empilée.</li><li>À l\'intérieur de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> est appelée et empilée.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> retourne, donc elle est dépilée.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> est empilée, exécutée, puis dépilée.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> se termine et est dépilée.</li></ul><p>La pile est maintenant vide. Simple, n\'est-ce pas ? Les problèmes surviennent lorsque nous essayons de faire quelque chose qui prend du temps, comme une requête réseau ou un minuteur. Si nous attendions de manière synchrone, toute la page se figerait. C\'est là que les API asynchrones entrent en jeu.</p><p></p><h2>3. JavaScript asynchrone – Sortir du fil</h2><p>Lorsque vous appelez une fonction asynchrone (par exemple, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> ou un écouteur d\'événement), elle ne bloque pas la pile. Au lieu de cela, le navigateur ou Node.js prend le relais.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Ce qui se passe en coulisses :</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> s\'exécute et est dépilée.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> est appelé. Son rappel est confié à l\'<strong>API web</strong> (un minuteur dans ce cas). Le minuteur commence à décompter en arrière-plan, <strong>en dehors</strong> du fil principal.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> s\'exécute immédiatement.</li><li>Après environ 1000 ms, l\'API web déplace le rappel vers la <strong>file d\'attente des rappels</strong>.</li><li>La <strong>boucle d\'événements</strong> vérifie constamment : <em>\"La pile d\'appels est-elle vide ?\"</em> Lorsqu\'elle l\'est, elle prend le premier rappel de la file et l\'empile pour exécution.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> est enregistré.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Même si le délai était de 0 ms <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, le rappel attendrait toujours dans la file jusqu\'à ce que la pile soit vide. C\'est pourquoi <strong>&quot;End&quot;</strong> est toujours enregistré avant <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. La boucle d\'événements – Le gardien éternel</h2><p>La boucle d\'événements a une tâche simple : <strong>surveiller la pile d\'appels et les files d\'attente de rappels</strong>. Si la pile est vide, elle prend le premier rappel en attente et l\'empile.</p><p>Mais il y a un twist : il existe en réalité <strong>deux</strong> types de files d\'attente : les <strong>macrotâches</strong> (ou simplement \"tâches\") et les <strong>microtâches</strong>. La boucle d\'événements les traite différemment.</p><p></p><h3>Macrotâches (ou Tâches)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), tâches d\'E/S, rendu UI.</li><li>Chaque itération de la boucle d\'événements traite <strong>une</strong> macrotâche de la file d\'attente des rappels.</li></ul><p></p><h3>Microtâches</h3><ul><li>Promesses (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Après <strong>chaque</strong> macrotâche, la boucle d\'événements vide <strong>toute la file d\'attente des microtâches</strong> avant de passer à la macrotâche suivante ou au rendu.</li></ul><p>Ce système de priorité est crucial. Voyons-le en action.</p><p></p><h2>5. Microtâches vs Macrotâches – Qui passe en premier ?</h2><p></p><p><strong>Considérez ce code :</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Sortie :</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Explication étape par étape :</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> s\'exécute, la pile se vide.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – le rappel est confié à l\'API web (minuteur avec 0 ms). Après 0 ms, il est déplacé vers la <strong>file d\'attente des macrotâches</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – le rappel <code>then</code> est une <strong>microtâche</strong>. Il est placé dans la file d\'attente des microtâches.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> s\'exécute immédiatement.</p><p>La pile d\'appels est maintenant vide.</p><p><strong>Point de contrôle des microtâches :</strong> Avant de prendre une macrotâche, la boucle d\'événements vide la file d\'attente des microtâches. Ainsi, <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span> s\'exécute, puis le deuxième <code>then</code> programme une autre microtâche, qui s\'exécute également immédiatement. <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span> est enregistrée.</p><p>La file d\'attente des microtâches est vide. Maintenant, la boucle d\'événements prend la prochaine macrotâche de la file – le rappel de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> est enregistré.</p><p>Cela explique pourquoi les promesses peuvent \"passer devant\" les minuteurs, même si le délai du minuteur est nul.</p><p></p><h2>6. Exemples pratiques qui clarifient la boucle d\'événements</h2><h3>Exemple 1 : Minuteurs et promesses mélangés</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Sortie : 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Exemple 2 : Microtâches récursives</h3><p>Que se passe-t-il si vous continuez à ajouter des microtâches à l\'intérieur d\'une microtâche ?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // programme une autre microtâche\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Cela enregistrera <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> indéfiniment, et le rappel de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> <strong>ne s\'exécutera jamais</strong> car la file d\'attente des microtâches n\'est jamais vidée. Cela peut affamer la boucle d\'événements – un danger réel si vous n\'êtes pas prudent.</p><p></p><h3>Exemple 3 : Boucle d\'événements et rendu UI (navigateur)</h3><p>Dans les navigateurs, le rendu (peinture) a lieu après les microtâches et avant la prochaine macrotâche. C\'est pourquoi vous pouvez voir des problèmes de layout si vous modifiez le DOM de façon répétée à l\'intérieur de microtâches.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Ce rappel est une macrotâche\r\n  Promise.resolve().then(() =&gt; {\r\n    // Cette microtâche s\'exécute avant le prochain rendu\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>Lorsque le bouton est cliqué, l\'ordre est :</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (macrotâche).</li><li>Toutes les microtâches (le rappel de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>).</li><li>Ensuite, le navigateur peut effectuer le rendu.</li></ul><p></p><h2>7. Pièges courants et comment les éviter</h2><h3>Bloquer la boucle d\'événements</h3><p>Le code synchrone de longue durée (par exemple, des boucles lourdes, des calculs complexes) empêche la boucle d\'événements de traiter d\'autres tâches. Votre interface utilisateur se fige et les autres rappels sont retardés.</p><p><strong>Solution :</strong> Divisez le travail lourd en morceaux plus petits en utilisant <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, ou déplacez-le vers un Web Worker (navigateur) / des threads de travail (Node.js).</p><h3></h3><h3>Oublier la priorité des microtâches</h3><p>Supposer que <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> s\'exécutera immédiatement après d\'autre code peut entraîner des conditions de concurrence.</p><p><strong>Solution :</strong> Comprenez la file d\'attente des microtâches. Utilisez <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> ou <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> lorsque vous devez différer mais toujours exécuter avant les E/S.</p><h3></h3><h3>Boucles infinies de microtâches</h3><p>Comme montré dans l\'exemple 2, l\'ajout récursif de microtâches peut affamer les macrotâches et les événements de rendu.</p><p><strong>Solution :</strong> Évitez la récursion sans limite dans les microtâches. Utilisez une macrotâche (comme <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) pour le travail différé de longue durée.</p><h3></h3><h3>Mélanger les mécanismes internes d\'async/await</h3><p>Les fonctions <strong>async</strong> ne sont que du sucre syntaxique sur les promesses. Chaque <strong>await</strong> crée une continuation de microtâche. Savoir cela vous aide à prédire l\'ordre d\'exécution.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // frontière de microtâche\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Sortie : 1, 3, 2\r\n</pre><p></p><h2>8. Conclusion</h2><p>La boucle d\'événements est le cœur de JavaScript. Elle permet à un langage monothread de gérer efficacement les opérations asynchrones, en gardant les applications réactives. En comprenant l\'interaction entre la pile d\'appels, les API web, la file d\'attente des macrotâches et la file d\'attente des microtâches, vous pouvez écrire un code prévisible et performant.</p><p><strong>Points clés à retenir :</strong></p><ul><li>JavaScript s\'exécute de manière synchrone sur la pile d\'appels.</li><li>Les API asynchrones délèguent le travail à l\'environnement (navigateur/Node).</li><li>Lorsque la pile est vide, la boucle d\'événements déplace les rappels des files d\'attente vers la pile.</li><li><strong>Les microtâches</strong> (promesses, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) ont une priorité plus élevée que <strong>les macrotâches</strong> (minuteurs, E/S).</li><li>La boucle d\'événements traite toutes les microtâches avant la prochaine macrotâche ou le prochain rendu.</li></ul><p>Maîtriser la boucle d\'événements n\'est pas seulement un sujet d\'entretien ; c\'est essentiel pour le débogage, éviter les goulots d\'étranglement de performance et vraiment comprendre comment JavaScript fonctionne sous le capot.</p>', 'Die JavaScript-Ereignisschleife verstehen: Der vollständige Leitfaden für Anfänger und Profis', '<p>JavaScript ist überall, von interaktiven Websites bis hin zu serverseitigen Anwendungen mit Node.js. Eine der leistungsstärksten (und oft missverstandenen) Funktionen der Sprache ist ihre Fähigkeit, viele Aufgaben scheinbar gleichzeitig zu bewältigen, obwohl sie <strong>einzelthreadig</strong> ist. Wie schafft sie das? Das Geheimnis ist die <strong>Ereignisschleife</strong>.</p><p></p><p><strong>In diesem Leitfaden entmystifizieren wir die JavaScript-Ereignisschleife. Sie lernen:</strong></p><ul><li>Was die Ereignisschleife ist und warum sie wichtig ist.</li><li>Wie der Aufrufstapel, Web-APIs und Rückrufwarteschlangen zusammenarbeiten.</li><li>Der Unterschied zwischen <strong>Mikrotasks</strong> und <strong>Makrotasks</strong>.</li><li>Praxisbeispiele, die die Ereignisschleife in Aktion zeigen.</li><li>Häufige Fallstricke und wie man sie vermeidet.</li></ul><p>Am Ende haben Sie ein solides Verständnis von asynchronem JavaScript – unerlässlich zum Debuggen, zum Schreiben effizienten Codes und zum Bestehen technischer Vorstellungsgespräche.</p><p></p><h2>1. Die JavaScript-Laufzeitumgebung</h2><p>Um die Ereignisschleife zu verstehen, benötigen wir zunächst einen Überblick über die JavaScript-Laufzeitumgebung (in einem Browser oder Node.js). Die Hauptkomponenten sind:</p><ul><li><strong>Heap</strong> – Wo Objekte im Speicher abgelegt werden.</li><li><strong>Aufrufstapel (Call Stack)</strong> – Eine LIFO-Struktur (Last In, First Out), die die Funktionsausführung verfolgt.</li><li><strong>Web-APIs / Node-APIs</strong> – Vom Browser bereitgestellte Funktionen wie <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, DOM-Ereignisse, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> oder das <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong>-Modul von Node.js. Sie laufen außerhalb des Hauptthreads.</li><li><strong>Rückrufwarteschlange</strong> (auch Aufgabenwarteschlange genannt) – Enthält Rückrufe von Web-APIs, die zur Ausführung bereit sind.</li><li><strong>Mikrotask-Warteschlange</strong> – Eine spezielle Warteschlange für Promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> und <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Ereignisschleife</strong> – Der Orchestrator, der Rückrufe aus den Warteschlangen in den Aufrufstapel verschiebt, wenn der Stapel leer ist.</li></ul><p></p><p></p><blockquote>? <strong>Hinweis:</strong> Die JavaScript-Engine selbst (wie V8) <strong>enthält nicht</strong> die Web-APIs oder die Ereignisschleife. Sie werden vom Browser oder der Node.js-Umgebung bereitgestellt.</blockquote><p></p><h2>2. Der Aufrufstapel – Synchrone Ausführung</h2><p>Der Aufrufstapel ist der Ort, an dem Ihr Code Zeile für Zeile ausgeführt wird. Wenn Sie eine Funktion aufrufen, wird sie auf den Stapel gelegt; wenn die Funktion zurückkehrt, wird sie vom Stapel genommen.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Schritt für Schritt:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> wird auf den Stapel gelegt.</li><li>Innerhalb von <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong> wird <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> aufgerufen und auf den Stapel gelegt.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> kehrt zurück, wird also vom Stapel genommen.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> wird auf den Stapel gelegt, ausgeführt und dann entfernt.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> endet und wird vom Stapel genommen.</li></ul><p>Der Stapel ist jetzt leer. Einfach, oder? Probleme treten auf, wenn wir etwas tun wollen, das Zeit braucht, wie eine Netzwerkanfrage oder einen Timer. Wenn wir synchron warten würden, würde die gesamte Seite einfrieren. Hier kommen asynchrone APIs ins Spiel.</p><p></p><h2>3. Asynchrones JavaScript – Auslagern</h2><p>Wenn Sie eine asynchrone Funktion aufrufen (z.B. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> oder einen Ereignis-Listener), blockiert sie nicht den Stapel. Stattdessen übernimmt der Browser oder Node.js.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Was hinter den Kulissen passiert:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> wird ausgeführt und vom Stapel genommen.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> wird aufgerufen. Sein Rückruf wird an die <strong>Web-API</strong> (in diesem Fall einen Timer) übergeben. Der Timer beginnt im Hintergrund herunterzuzählen, <strong>außerhalb</strong> des Hauptthreads.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> wird sofort ausgeführt.</li><li>Nach etwa 1000 ms verschiebt die Web-API den Rückruf in die <strong>Rückrufwarteschlange</strong>.</li><li>Die <strong>Ereignisschleife</strong> prüft ständig: <em>\"Ist der Aufrufstapel leer?\"</em> Wenn ja, nimmt sie den ersten Rückruf aus der Warteschlange und legt ihn zur Ausführung auf den Stapel.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> wird protokolliert.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Selbst wenn die Verzögerung 0 ms betragen würde <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, würde der Rückruf immer noch in der Warteschlange warten, bis der Stapel leer ist. Deshalb wird <strong>&quot;End&quot;</strong> immer vor <strong>&quot;Timeout&quot;</strong> protokolliert.</p><p></p><h2>4. Die Ereignisschleife – Der ewige Wächter</h2><p>Die Ereignisschleife hat eine einfache Aufgabe: <strong>Überwachen des Aufrufstapels und der Rückrufwarteschlangen</strong>. Wenn der Stapel leer ist, nimmt sie den ersten wartenden Rückruf und legt ihn auf den Stapel.</p><p>Aber es gibt eine Besonderheit – es gibt tatsächlich <strong>zwei</strong> Arten von Warteschlangen: <strong>Makrotasks</strong> (oder einfach \"Tasks\") und <strong>Mikrotasks</strong>. Die Ereignisschleife behandelt sie unterschiedlich.</p><p></p><h3>Makrotasks (oder Tasks)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), E/A-Aufgaben, UI-Rendering.</li><li>Jede Iteration der Ereignisschleife verarbeitet <strong>eine</strong> Makrotask aus der Rückrufwarteschlange.</li></ul><p></p><h3>Mikrotasks</h3><ul><li>Promises (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Nach <strong>jeder</strong> Makrotask leert die Ereignisschleife <strong>die gesamte Mikrotask-Warteschlange</strong>, bevor sie zur nächsten Makrotask oder zum Rendern übergeht.</li></ul><p>Dieses Prioritätssystem ist entscheidend. Sehen wir es in Aktion.</p><p></p><h2>5. Mikrotasks vs. Makrotasks – Wer kommt zuerst?</h2><p></p><p><strong>Betrachten Sie diesen Code:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Ausgabe:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Schritt-für-Schritt-Erklärung:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> wird ausgeführt, der Stapel leert sich.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – der Rückruf wird an die Web-API übergeben (Timer mit 0 ms). Nach 0 ms wird er in die <strong>Makrotask-Warteschlange</strong> verschoben.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – der <code>then</code>-Rückruf ist eine <strong>Mikrotask</strong>. Er wird in die Mikrotask-Warteschlange gestellt.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> wird sofort ausgeführt.</p><p>Der Aufrufstapel ist jetzt leer.</p><p><strong>Mikrotask-Checkpoint:</strong> Bevor eine Makrotask entnommen wird, leert die Ereignisschleife die Mikrotask-Warteschlange. Also läuft <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span>, dann plant der zweite <code>then</code> eine weitere Mikrotask, die ebenfalls sofort ausgeführt wird. <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span> wird protokolliert.</p><p>Die Mikrotask-Warteschlange ist leer. Nun nimmt die Ereignisschleife die nächste Makrotask aus der Warteschlange – den <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>-Rückruf. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> wird protokolliert.</p><p>Dies erklärt, warum Promises Timern \"vorspringen\" können, selbst wenn die Timer-Verzögerung null ist.</p><p></p><h2>6. Praxisbeispiele, die die Ereignisschleife verdeutlichen</h2><h3>Beispiel 1: Gemischte Timer und Promises</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Ausgabe: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Beispiel 2: Rekursive Mikrotasks</h3><p>Was passiert, wenn Sie innerhalb einer Mikrotask immer wieder Mikrotasks hinzufügen?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // plant eine weitere Mikrotask\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Dies wird <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> endlos protokollieren, und der <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>-Rückruf wird <strong>niemals</strong> ausgeführt, weil die Mikrotask-Warteschlange nie geleert wird. Dies kann die Ereignisschleife aushungern – eine echte Gefahr, wenn man nicht vorsichtig ist.</p><p></p><h3>Beispiel 3: Ereignisschleife und UI-Rendering (Browser)</h3><p>In Browsern erfolgt das Rendern (Malen) nach den Mikrotasks und vor der nächsten Makrotask. Deshalb kann es zu Layout-Problemen kommen, wenn Sie das DOM wiederholt innerhalb von Mikrotasks ändern.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Dieser Rückruf ist eine Makrotask\r\n  Promise.resolve().then(() =&gt; {\r\n    // Diese Mikrotask läuft vor dem nächsten Rendern\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>Wenn der Button geklickt wird, ist die Reihenfolge:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (Makrotask).</li><li>Alle Mikrotasks (der <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>-Rückruf).</li><li>Dann kann der Browser rendern.</li></ul><p></p><h2>7. Häufige Fallstricke und wie man sie vermeidet</h2><h3>Blockieren der Ereignisschleife</h3><p>Langlaufender synchroner Code (z.B. schwere Schleifen, komplexe Berechnungen) verhindert, dass die Ereignisschleife andere Aufgaben verarbeitet. Ihre Benutzeroberfläche friert ein und andere Rückrufe werden verzögert.</p><p><strong>Lösung:</strong> Teilen Sie schwere Arbeiten in kleinere Stücke auf, indem Sie <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> verwenden, oder verlagern Sie sie in einen Web Worker (Browser) / Worker-Threads (Node.js).</p><h3></h3><h3>Vergessen der Mikrotask-Priorität</h3><p>Anzunehmen, dass <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> sofort nach anderem Code ausgeführt wird, kann zu Wettlaufsituationen führen.</p><p><strong>Lösung:</strong> Verstehen Sie die Mikrotask-Warteschlange. Verwenden Sie <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> oder <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong>, wenn Sie verzögern, aber dennoch vor E/A ausführen müssen.</p><h3></h3><h3>Endlose Mikrotask-Schleifen</h3><p>Wie in Beispiel 2 gezeigt, kann das rekursive Hinzufügen von Mikrotasks Makrotasks und Render-Ereignisse aushungern.</p><p><strong>Lösung:</strong> Vermeiden Sie unbegrenzte Rekursion in Mikrotasks. Verwenden Sie eine Makrotask (wie <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) für langlaufende, verzögerte Arbeiten.</p><h3></h3><h3>Mischen von Async/Await-Interna</h3><p><strong>async</strong>-Funktionen sind nur syntaktischer Zucker für Promises. Jedes <strong>await</strong> erzeugt eine Mikrotask-Fortsetzung. Dies zu wissen hilft Ihnen, die Ausführungsreihenfolge vorherzusagen.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // Mikrotask-Grenze\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Ausgabe: 1, 3, 2\r\n</pre><p></p><h2>8. Fazit</h2><p>Die Ereignisschleife ist der Herzschlag von JavaScript. Sie ermöglicht es einer einzelthreadigen Sprache, asynchrone Operationen effizient zu handhaben und Anwendungen reaktionsfähig zu halten. Indem Sie das Zusammenspiel zwischen Aufrufstapel, Web-APIs, Makrotask-Warteschlange und Mikrotask-Warteschlange verstehen, können Sie vorhersehbaren und leistungsstarken Code schreiben.</p><p><strong>Wichtige Erkenntnisse:</strong></p><ul><li>JavaScript läuft synchron auf dem Aufrufstapel.</li><li>Asynchrone APIs delegieren Arbeit an die Umgebung (Browser/Node).</li><li>Wenn der Stapel leer ist, verschiebt die Ereignisschleife Rückrufe aus den Warteschlangen auf den Stapel.</li><li><strong>Mikrotasks</strong> (Promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) haben eine höhere Priorität als <strong>Makrotasks</strong> (Timer, E/A).</li><li>Die Ereignisschleife verarbeitet alle Mikrotasks vor der nächsten Makrotask oder dem nächsten Rendern.</li></ul><p>Die Beherrschung der Ereignisschleife ist nicht nur ein Thema für Vorstellungsgespräche – sie ist essentiell zum Debuggen, zur Vermeidung von Leistungsengpässen und zum wirklichen Verständnis, wie JavaScript unter der Haube funktioniert.</p>', 'Entendendo o Loop de Eventos do JavaScript: O Guia Completo para Iniciantes e Profissionais', '<p>JavaScript está em todos os lugares, desde sites interativos até aplicações do lado do servidor com Node.js. Um dos recursos mais poderosos (e muitas vezes mal compreendidos) da linguagem é sua capacidade de lidar com muitas tarefas aparentemente ao mesmo tempo, apesar de ser <strong>single-threaded</strong>. Como ele consegue isso? O segredo é o <strong>loop de eventos</strong>.</p><p></p><p><strong>Neste guia, vamos desmistificar o loop de eventos do JavaScript. Você aprenderá:</strong></p><ul><li>O que é o loop de eventos e por que ele é importante.</li><li>Como a pilha de chamadas, as APIs web e as filas de callbacks trabalham juntas.</li><li>A diferença entre <strong>microtarefas</strong> e <strong>macrotarefas</strong>.</li><li>Exemplos do mundo real que mostram o loop de eventos em ação.</li><li>Armadilhas comuns e como evitá-las.</li></ul><p>Ao final, você terá um sólido entendimento de JavaScript assíncrono — essencial para depuração, escrita de código eficiente e sucesso em entrevistas técnicas.</p><p></p><h2>1. O Ambiente de Execução do JavaScript</h2><p>Para entender o loop de eventos, primeiro precisamos de uma visão geral do ambiente de execução do JavaScript (em um navegador ou Node.js). Os principais componentes são:</p><ul><li><strong>Heap</strong> – Onde os objetos são armazenados na memória.</li><li><strong>Pilha de Chamadas (Call Stack)</strong> – Uma estrutura LIFO (último a entrar, primeiro a sair) que rastreia a execução de funções.</li><li><strong>APIs Web / APIs Node</strong> – Recursos fornecidos pelo navegador como <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, eventos DOM, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>, ou o módulo <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> do Node.js. Eles executam fora da thread principal.</li><li><strong>Fila de Callbacks</strong> (também chamada de Fila de Tarefas) – Contém callbacks de APIs web que estão prontos para executar.</li><li><strong>Fila de Microtarefas</strong> – Uma fila especial para promessas, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> e <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Loop de Eventos</strong> – O orquestrador que move callbacks das filas para a pilha de chamadas quando a pilha está vazia.</li></ul><p></p><p></p><blockquote>? <strong>Nota:</strong> O motor JavaScript em si (como o V8) <strong>não</strong> inclui as APIs web ou o loop de eventos. Eles são fornecidos pelo navegador ou ambiente Node.js.</blockquote><p></p><h2>2. A Pilha de Chamadas – Execução Síncrona</h2><p>A pilha de chamadas é onde seu código executa linha por linha. Quando você chama uma função, ela é empilhada; quando a função retorna, ela é desempilhada.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Passo a passo:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> é empilhada.</li><li>Dentro de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> é chamada e empilhada.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> retorna, então é desempilhada.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> é empilhada, executada e depois desempilhada.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> termina e é desempilhada.</li></ul><p>A pilha agora está vazia. Simples, certo? Os problemas surgem quando tentamos fazer algo que leva tempo, como uma requisição de rede ou um timer. Se esperássemos de forma síncrona, a página inteira congelaria. É aí que entram as APIs assíncronas.</p><p></p><h2>3. JavaScript Assíncrono – Saindo da Thread</h2><p>Quando você chama uma função assíncrona (por exemplo, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> ou um listener de evento), ela não bloqueia a pilha. Em vez disso, o navegador ou Node.js assume o controle.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>O que acontece nos bastidores:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> executa e é desempilhada.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> é chamado. Seu callback é entregue à <strong>API web</strong> (um timer neste caso). O timer começa a contar em segundo plano, <strong>fora</strong> da thread principal.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> executa imediatamente.</li><li>Após cerca de 1000 ms, a API web move o callback para a <strong>fila de callbacks</strong>.</li><li>O <strong>loop de eventos</strong> verifica constantemente: <em>\"A pilha de chamadas está vazia?\"</em> Quando está, ele pega o primeiro callback da fila e o empilha para execução.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> é registrado.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Mesmo se o atraso fosse 0 ms <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, o callback ainda esperaria na fila até a pilha estar vazia. É por isso que <strong>&quot;End&quot;</strong> sempre é registrado antes de <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. O Loop de Eventos – O Guardião Eterno</h2><p>O loop de eventos tem um trabalho simples: <strong>monitorar a pilha de chamadas e as filas de callbacks</strong>. Se a pilha estiver vazia, ele pega o primeiro callback na espera e o empilha.</p><p>Mas há uma reviravolta — existem na verdade <strong>dois</strong> tipos de filas: <strong>macrotarefas</strong> (ou apenas \"tarefas\") e <strong>microtarefas</strong>. O loop de eventos as trata de forma diferente.</p><p></p><h3>Macrotarefas (ou Tarefas)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), tarefas de E/S, renderização de UI.</li><li>Cada iteração do loop de eventos processa <strong>uma</strong> macrotarefa da fila de callbacks.</li></ul><p></p><h3>Microtarefas</h3><ul><li>Promessas (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Após <strong>cada</strong> macrotarefa, o loop de eventos esvazia <strong>toda a fila de microtarefas</strong> antes de passar para a próxima macrotarefa ou renderização.</li></ul><p>Este sistema de prioridade é crucial. Vamos vê-lo em ação.</p><p></p><h2>5. Microtarefas vs Macrotarefas – Quem Vai Primeiro?</h2><p></p><p><strong>Considere este código:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Saída:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Explicação passo a passo:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> executa, a pilha esvazia.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – o callback é entregue à API web (timer com 0 ms). Após 0 ms, ele é movido para a <strong>fila de macrotarefas</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – o callback <code>then</code> é uma <strong>microtarefa</strong>. Ele é colocado na fila de microtarefas.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> executa imediatamente.</p><p>A pilha de chamadas agora está vazia.</p><p><strong>Ponto de verificação de microtarefas:</strong> Antes de pegar qualquer macrotarefa, o loop de eventos esvazia a fila de microtarefas. Então <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span> executa, então o segundo <code>then</code> agenda outra microtarefa, que também executa imediatamente. <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span> é registrada.</p><p>A fila de microtarefas está vazia. Agora o loop de eventos pega a próxima macrotarefa da fila – o callback do <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> é registrado.</p><p>Isso explica por que as promessas podem \"pular na frente\" dos timers, mesmo se o atraso do timer for zero.</p><p></p><h2>6. Exemplos Práticos que Esclarecem o Loop de Eventos</h2><h3>Exemplo 1: Timers e Promessas Misturados</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Saída: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Exemplo 2: Microtarefas Recursivas</h3><p>O que acontece se você continuar adicionando microtarefas dentro de uma microtarefa?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // agenda outra microtarefa\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Isso registrará <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> indefinidamente, e o callback do <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> <strong>nunca</strong> executará porque a fila de microtarefas nunca é esvaziada. Isso pode sobrecarregar o loop de eventos – um perigo real se você não tomar cuidado.</p><p></p><h3>Exemplo 3: Loop de Eventos e Renderização de UI (navegador)</h3><p>Em navegadores, a renderização (pintura) acontece após as microtarefas e antes da próxima macrotarefa. É por isso que você pode ver problemas de layout se modificar o DOM repetidamente dentro de microtarefas.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Este callback é uma macrotarefa\r\n  Promise.resolve().then(() =&gt; {\r\n    // Esta microtarefa executa antes da próxima renderização\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>Quando o botão é clicado, a ordem é:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (macrotarefa).</li><li>Todas as microtarefas (o callback do <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>).</li><li>Então o navegador pode renderizar.</li></ul><p></p><h2>7. Armadilhas Comuns e Como Evitá-las</h2><h3>Bloqueando o Loop de Eventos</h3><p>Código síncrono de longa duração (por exemplo, loops pesados, cálculos complexos) impede que o loop de eventos processe outras tarefas. Sua UI congela e outros callbacks são atrasados.</p><p><strong>Solução:</strong> Divida o trabalho pesado em partes menores usando <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, ou mova-o para um Web Worker (navegador) / threads de trabalho (Node.js).</p><h3></h3><h3>Esquecendo a Prioridade das Microtarefas</h3><p>Supor que <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> executará imediatamente após outro código pode levar a condições de corrida.</p><p><strong>Solução:</strong> Entenda a fila de microtarefas. Use <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> ou <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> quando precisar adiar, mas ainda executar antes de E/S.</p><h3></h3><h3>Loops Infinitos de Microtarefas</h3><p>Como mostrado no Exemplo 2, adicionar microtarefas recursivamente pode sobrecarregar macrotarefas e eventos de renderização.</p><p><strong>Solução:</strong> Evite recursão ilimitada em microtarefas. Use uma macrotarefa (como <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) para trabalho adiado de longa duração.</p><h3></h3><h3>Misturando Internamente Async/Await</h3><p>Funções <strong>async</strong> são apenas açúcar sintático sobre promessas. Cada <strong>await</strong> cria uma continuação de microtarefa. Saber isso ajuda você a prever a ordem de execução.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // fronteira de microtarefa\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Saída: 1, 3, 2\r\n</pre><p></p><h2>8. Conclusão</h2><p>O loop de eventos é o coração do JavaScript. Ele permite que uma linguagem single-threaded lide com operações assíncronas de forma eficiente, mantendo as aplicações responsivas. Ao entender a interação entre a pilha de chamadas, as APIs web, a fila de macrotarefas e a fila de microtarefas, você pode escrever código previsível e de alto desempenho.</p><p><strong>Principais conclusões:</strong></p><ul><li>JavaScript executa sincronamente na pilha de chamadas.</li><li>APIs assíncronas delegam trabalho ao ambiente (navegador/Node).</li><li>Quando a pilha está vazia, o loop de eventos move callbacks das filas para a pilha.</li><li><strong>Microtarefas</strong> (promessas, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) têm prioridade maior que <strong>macrotarefas</strong> (timers, E/S).</li><li>O loop de eventos processa todas as microtarefas antes da próxima macrotarefa ou renderização.</li></ul><p>Dominar o loop de eventos não é apenas um tópico de entrevista — é essencial para depuração, evitar gargalos de desempenho e entender verdadeiramente como o JavaScript funciona internamente.</p>', 'JavaScriptイベントループを理解する：初心者からプロのための完全ガイド', '<p>JavaScriptは、インタラクティブなWebサイトからNode.jsを使ったサーバーサイドアプリケーションまで、あらゆる場所で使用されています。この言語の最も強力な（そしてしばしば誤解される）機能の1つは、<strong>シングルスレッド</strong>でありながら、多くのタスクを同時に処理しているように見える能力です。どのようにしてこれを実現しているのでしょうか？その秘密は<strong>イベントループ</strong>にあります。</p><p></p><p><strong>このガイドでは、JavaScriptイベントループの謎を解き明かします。学べること：</strong></p><ul><li>イベントループとは何か、そしてなぜ重要なのか。</li><li>コールスタック、Web API、コールバックキューがどのように連携するか。</li><li><strong>マイクロタスク</strong>と<strong>マクロタスク</strong>の違い。</li><li>イベントループの動作を示す実際の例。</li><li>よくある落とし穴とその回避方法。</li></ul><p>最後には、非同期JavaScriptをしっかりと理解できるようになります。これはデバッグ、効率的なコードの作成、技術面接での成功に不可欠です。</p><p></p><h2>1. JavaScript実行環境</h2><p>イベントループを理解するには、まずJavaScript実行環境（ブラウザまたはNode.js）の全体像を把握する必要があります。主な構成要素は次のとおりです。</p><ul><li><strong>ヒープ</strong> – オブジェクトがメモリに格納される領域。</li><li><strong>コールスタック</strong> – 関数の実行を追跡するLIFO（後入れ先出し）構造。</li><li><strong>Web API / Node API</strong> – <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>、DOMイベント、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>、またはNode.jsの<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong>モジュールなど、ブラウザが提供する機能。これらはメインスレッドの外部で実行されます。</li><li><strong>コールバックキュー</strong>（タスクキューとも呼ばれる） – 実行準備が整ったWeb APIからのコールバックを保持します。</li><li><strong>マイクロタスクキュー</strong> – プロミス、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong>、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</span></strong>のための特別なキュー。</li><li><strong>イベントループ</strong> – スタックが空になったときに、コールバックをキューからコールスタックに移動させるオーケストレーター。</li></ul><p></p><p></p><blockquote>? <strong>注：</strong> JavaScriptエンジン自体（V8など）には、Web APIやイベントループは<strong>含まれていません</strong>。これらはブラウザまたはNode.js環境によって提供されます。</blockquote><p></p><h2>2. コールスタック – 同期的実行</h2><p>コールスタックは、コードが1行ずつ実行される場所です。関数を呼び出すと、スタックにプッシュされ、関数が戻るとポップされます。</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>ステップバイステップ：</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong>がスタックにプッシュされます。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong>内で<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong>が呼び出され、スタックにプッシュされます。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong>が戻り、スタックからポップされます。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong>がプッシュされ、実行され、ポップされます。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong>が終了し、ポップされます。</li></ul><p>スタックは空になりました。シンプルですね？問題が発生するのは、ネットワークリクエストやタイマーなど、時間のかかることをしようとしたときです。同期的に待機すると、ページ全体がフリーズします。そこで非同期APIの出番です。</p><p></p><h2>3. 非同期JavaScript – 外部への委譲</h2><p>非同期関数（例：<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>、イベントリスナー）を呼び出すと、スタックをブロックしません。代わりに、ブラウザまたはNode.jsが引き継ぎます。</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>舞台裏で何が起こっているか：</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong>が実行され、ポップされます。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>が呼び出されます。そのコールバックは<strong>Web API</strong>（この場合はタイマー）に引き渡されます。タイマーはバックグラウンドでカウントダウンを開始し、<strong>メインスレッドの外部</strong>で動作します。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong>がすぐに実行されます。</li><li>約1000ミリ秒後、Web APIはコールバックを<strong>コールバックキュー</strong>に移動します。</li><li><strong>イベントループ</strong>は常にチェックしています：<em>\"コールスタックは空か？\"</em> 空になったら、キューから最初のコールバックを取り出し、実行のためにスタックにプッシュします。</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</span></strong>がログに記録されます。</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>たとえ遅延が0ミリ秒でも<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>、コールバックはスタックが空になるまでキューで待機します。これが<strong>&quot;End&quot;</strong>が常に<strong>&quot;Timeout&quot;</strong>より先にログに記録される理由です。</p><p></p><h2>4. イベントループ – 永遠の門番</h2><p>イベントループの仕事は単純です：<strong>コールスタックとコールバックキューを監視する</strong>こと。スタックが空であれば、待機中の最初のコールバックを取り出してスタックにプッシュします。</p><p>しかし、ここにひねりがあります。実際には<strong>2種類</strong>のキューがあります：<strong>マクロタスク</strong>（単に「タスク」とも呼ばれる）と<strong>マイクロタスク</strong>です。イベントループはこれらを異なる方法で処理します。</p><p></p><h3>マクロタスク（またはタスク）</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong>（Node.js）、I/Oタスク、UIレンダリング。</li><li>イベントループの各イテレーションは、コールバックキューから<strong>1つ</strong>のマクロタスクを処理します。</li></ul><p></p><h3>マイクロタスク</h3><ul><li>プロミス（<strong class=\"ql-font-monospace\">then</strong>、<strong class=\"ql-font-monospace\">catch</strong>、<strong class=\"ql-font-monospace\">finally</strong>）、<strong class=\"ql-font-monospace\">async/await</strong>、<strong class=\"ql-font-monospace\">MutationObserver</strong>、<strong class=\"ql-font-monospace\">queueMicrotask</strong>。</li><li><strong>各</strong>マクロタスクの後、イベントループは次のマクロタスクまたはレンダリングに移る前に、<strong>マイクロタスクキュー全体を空にします</strong>。</li></ul><p>この優先順位システムは非常に重要です。実際に見てみましょう。</p><p></p><h2>5. マイクロタスク vs マクロタスク – どちらが先か？</h2><p></p><p><strong>次のコードを考えてみましょう：</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>出力：</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>ステップバイステップの説明：</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong>が実行され、スタックが空になります。</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – コールバックがWeb API（0ミリ秒のタイマー）に渡されます。0ミリ秒後、<strong>マクロタスクキュー</strong>に移動します。</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – <code>then</code>コールバックは<strong>マイクロタスク</strong>です。マイクロタスクキューに配置されます。</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong>がすぐに実行されます。</p><p>コールスタックが空になりました。</p><p><strong>マイクロタスクチェックポイント：</strong> マクロタスクを取得する前に、イベントループはマイクロタスクキューを空にします。そのため、<span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span>が実行され、次に2番目の<code>then</code>が別のマイクロタスクをスケジュールし、それもすぐに実行されます。<span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span>がログに記録されます。</p><p>マイクロタスクキューが空になりました。イベントループはキューから次のマクロタスク（<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>コールバック）を取得します。<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>がログに記録されます。</p><p>これが、タイマーの遅延が0であっても、プロミスがタイマーより「先に進む」理由を説明しています。</p><p></p><h2>6. イベントループを明確にする実用的な例</h2><h3>例1：タイマーとプロミスの混合</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// 出力：1, 5, 3, 4, 2\r\n</pre><p></p><h3>例2：再帰的マイクロタスク</h3><p>マイクロタスク内でマイクロタスクを追加し続けるとどうなるでしょうか？</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // 別のマイクロタスクをスケジュール\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>これは<code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code>を無限にログに記録し、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>コールバックは<strong>決して</strong>実行されません。マイクロタスクキューが空にならないからです。これによりイベントループが飢餓状態になる可能性があります – 注意しないと実際に危険です。</p><p></p><h3>例3：イベントループとUIレンダリング（ブラウザ）</h3><p>ブラウザでは、レンダリング（描画）はマイクロタスクの後、次のマクロタスクの前に発生します。そのため、マイクロタスク内でDOMを繰り返し変更すると、レイアウトスラッシングが発生する可能性があります。</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // このコールバックはマクロタスク\r\n  Promise.resolve().then(() =&gt; {\r\n    // このマイクロタスクは次のレンダリング前に実行される\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>ボタンがクリックされたときの順序：</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code>（マクロタスク）。</li><li>すべてのマイクロタスク（<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>コールバック）。</li><li>その後、ブラウザがレンダリングする可能性があります。</li></ul><p></p><h2>7. よくある落とし穴とその回避方法</h2><h3>イベントループのブロック</h3><p>長時間実行される同期コード（例：重いループ、複雑な計算）は、イベントループが他のタスクを処理するのを妨げます。UIがフリーズし、他のコールバックが遅延します。</p><p><strong>解決策：</strong> <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>を使用して重い作業を小さなチャンクに分割するか、Web Worker（ブラウザ）/ワーカースレッド（Node.js）に移動します。</p><h3></h3><h3>マイクロタスクの優先順位を忘れる</h3><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong>が他のコードの直後に実行されると想定すると、競合状態を引き起こす可能性があります。</p><p><strong>解決策：</strong> マイクロタスクキューを理解してください。遅延させたいがI/Oの前には実行したい場合は、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>または<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong>を使用します。</p><h3></h3><h3>無限マイクロタスクループ</h3><p>例2で示したように、再帰的にマイクロタスクを追加すると、マクロタスクやレンダリングイベントが飢餓状態になります。</p><p><strong>解決策：</strong> マイクロタスクでの無制限の再帰を避けてください。長時間実行される遅延作業には、マクロタスク（<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>など）を使用します。</p><h3></h3><h3>Async/Awaitの内部構造の混同</h3><p><strong>async</strong>関数はプロミス上のシンタックスシュガーにすぎません。各<strong>await</strong>はマイクロタスクの継続を生成します。これを知っていると、実行順序を予測するのに役立ちます。</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // マイクロタスクの境界\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// 出力：1, 3, 2\r\n</pre><p></p><h2>8. 結論</h2><p>イベントループはJavaScriptの鼓動です。シングルスレッド言語が非同期操作を効率的に処理し、アプリケーションの応答性を維持することを可能にします。コールスタック、Web API、マクロタスクキュー、マイクロタスクキュー間の相互作用を理解することで、予測可能でパフォーマンスの高いコードを書くことができます。</p><p><strong>重要なポイント：</strong></p><ul><li>JavaScriptはコールスタック上で同期的に実行されます。</li><li>非同期APIは作業を環境（ブラウザ/Node）に委譲します。</li><li>スタックが空のとき、イベントループはコールバックをキューからスタックに移動します。</li><li><strong>マイクロタスク</strong>（プロミス、<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>）は<strong>マクロタスク</strong>（タイマー、I/O）よりも優先度が高い。</li><li>イベントループは、次のマクロタスクまたはレンダリングの前に、すべてのマイクロタスクを処理します。</li></ul><p>イベントループをマスターすることは、面接のトピックに過ぎません – デバッグ、パフォーマンスのボトルネックの回避、JavaScriptが内部でどのように機能するかを真に理解するために不可欠です。</p>', 'Понимание цикла событий JavaScript: Полное руководство для новичков и профессионалов', '<p>JavaScript повсюду: от интерактивных веб-сайтов до серверных приложений на Node.js. Одна из самых мощных (и часто неправильно понимаемых) особенностей языка — это его способность одновременно обрабатывать множество задач, несмотря на то, что он <strong>однопоточный</strong>. Как ему это удаётся? Секрет кроется в <strong>цикле событий</strong>.</p><p></p><p><strong>В этом руководстве мы разберёмся в цикле событий JavaScript. Вы узнаете:</strong></p><ul><li>Что такое цикл событий и почему он важен.</li><li>Как стек вызовов, веб-API и очереди обратных вызовов работают вместе.</li><li>Разницу между <strong>микрозадачами</strong> и <strong>макрозадачами</strong>.</li><li>Реальные примеры, демонстрирующие цикл событий в действии.</li><li>Распространённые ошибки и способы их избежать.</li></ul><p>В итоге вы получите твёрдое понимание асинхронного JavaScript — необходимое для отладки, написания эффективного кода и успешного прохождения технических собеседований.</p><p></p><h2>1. Среда выполнения JavaScript</h2><p>Чтобы понять цикл событий, сначала нужно взглянуть на среду выполнения JavaScript (в браузере или Node.js). Основные компоненты:</p><ul><li><strong>Куча</strong> – место хранения объектов в памяти.</li><li><strong>Стек вызовов</strong> – структура LIFO (последним пришёл — первым вышел), отслеживающая выполнение функций.</li><li><strong>Веб-API / Node API</strong> – функции, предоставляемые браузером, такие как <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, события DOM, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> или модуль <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> в Node.js. Они выполняются вне основного потока.</li><li><strong>Очередь обратных вызовов</strong> (также называемая очередью задач) – содержит обратные вызовы от веб-API, готовые к выполнению.</li><li><strong>Очередь микрозадач</strong> – специальная очередь для промисов, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> и <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Цикл событий</strong> – координатор, который перемещает обратные вызовы из очередей в стек вызовов, когда стек пуст.</li></ul><p></p><p></p><blockquote>? <strong>Примечание:</strong> Сам движок JavaScript (например, V8) <strong>не включает</strong> веб-API или цикл событий. Они предоставляются браузером или средой Node.js.</blockquote><p></p><h2>2. Стек вызовов – синхронное выполнение</h2><p>Стек вызовов — это место, где ваш код выполняется строка за строкой. Когда вы вызываете функцию, она помещается в стек; когда функция возвращает результат, она извлекается из стека.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Шаг за шагом:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> помещается в стек.</li><li>Внутри <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong> вызывается <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> и помещается в стек.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> возвращает результат, поэтому извлекается из стека.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> помещается в стек, выполняется, затем извлекается.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> завершается и извлекается.</li></ul><p>Теперь стек пуст. Просто, верно? Проблемы возникают, когда мы пытаемся сделать что-то, требующее времени, например сетевой запрос или таймер. Если бы мы ждали синхронно, вся страница замерла бы. Вот тут и вступают в игру асинхронные API.</p><p></p><h2>3. Асинхронный JavaScript – выход за пределы потока</h2><p>Когда вы вызываете асинхронную функцию (например, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> или обработчик событий), она не блокирует стек. Вместо этого управление передаётся браузеру или Node.js.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Что происходит за кулисами:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> выполняется и извлекается.</li><li>Вызывается <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. Его обратный вызов передаётся <strong>веб-API</strong> (в данном случае таймеру). Таймер начинает отсчёт в фоновом режиме, <strong>вне</strong> основного потока.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> выполняется немедленно.</li><li>Примерно через 1000 мс веб-API перемещает обратный вызов в <strong>очередь обратных вызовов</strong>.</li><li><strong>Цикл событий</strong> постоянно проверяет: <em>«Стек вызовов пуст?»</em> Когда он пуст, цикл берёт первый обратный вызов из очереди и помещает его в стек для выполнения.</li><li>В консоль выводится <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Даже если задержка составляет 0 мс <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, обратный вызов всё равно будет ждать в очереди, пока стек не освободится. Вот почему <strong>&quot;End&quot;</strong> всегда выводится раньше <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. Цикл событий – вечный страж</h2><p>У цикла событий одна простая задача: <strong>следить за стеком вызовов и очередями обратных вызовов</strong>. Если стек пуст, он берёт первый ожидающий обратный вызов и помещает его в стек.</p><p>Но есть нюанс — на самом деле существуют <strong>два</strong> типа очередей: <strong>макрозадачи</strong> (или просто «задачи») и <strong>микрозадачи</strong>. Цикл событий обрабатывает их по-разному.</p><p></p><h3>Макрозадачи (или задачи)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), задачи ввода-вывода, рендеринг интерфейса.</li><li>Каждая итерация цикла событий обрабатывает <strong>одну</strong> макрозадачу из очереди обратных вызовов.</li></ul><p></p><h3>Микрозадачи</h3><ul><li>Промисы (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>После <strong>каждой</strong> макрозадачи цикл событий очищает <strong>всю очередь микрозадач</strong>, прежде чем перейти к следующей макрозадаче или рендерингу.</li></ul><p>Эта система приоритетов критически важна. Давайте посмотрим на неё в действии.</p><p></p><h2>5. Микрозадачи против макрозадач – кто первый?</h2><p></p><p><strong>Рассмотрим этот код:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Вывод:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Пошаговое объяснение:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> выполняется, стек пустеет.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – обратный вызов передаётся веб-API (таймер с 0 мс). Через 0 мс он перемещается в <strong>очередь макрозадач</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – обратный вызов <code>then</code> является <strong>микрозадачей</strong>. Он помещается в очередь микрозадач.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> выполняется немедленно.</p><p>Стек вызовов теперь пуст.</p><p><strong>Контрольная точка микрозадач:</strong> Прежде чем взять какую-либо макрозадачу, цикл событий очищает очередь микрозадач. Таким образом, выполняется <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span>, затем второй <code>then</code> планирует ещё одну микрозадачу, которая тоже выполняется сразу. В консоль выводится <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span>.</p><p>Очередь микрозадач пуста. Теперь цикл событий берёт следующую макрозадачу из очереди – обратный вызов <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. Выводится <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</p><p>Это объясняет, почему промисы могут «обгонять» таймеры, даже если задержка таймера равна нулю.</p><p></p><h2>6. Практические примеры, поясняющие цикл событий</h2><h3>Пример 1: Смешанные таймеры и промисы</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Вывод: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Пример 2: Рекурсивные микрозадачи</h3><p>Что произойдёт, если вы будете добавлять микрозадачи внутри микрозадачи?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // планирует ещё одну микрозадачу\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Этот код будет бесконечно выводить <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code>, и обратный вызов <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> <strong>никогда</strong> не выполнится, потому что очередь микрозадач никогда не опустеет. Это может «заморить голодом» цикл событий – реальная опасность, если не быть осторожным.</p><p></p><h3>Пример 3: Цикл событий и рендеринг интерфейса (браузер)</h3><p>В браузерах рендеринг (отрисовка) происходит после микрозадач и перед следующей макрозадачей. Вот почему вы можете наблюдать « thrashing» (частые перерисовки) layout, если многократно изменять DOM внутри микрозадач.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Этот обратный вызов — макрозадача\r\n  Promise.resolve().then(() =&gt; {\r\n    // Эта микрозадача выполняется до следующего рендеринга\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>При нажатии на кнопку порядок такой:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (макрозадача).</li><li>Все микрозадачи (обратный вызов <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>).</li><li>Затем браузер может выполнить рендеринг.</li></ul><p></p><h2>7. Распространённые ошибки и способы их избежать</h2><h3>Блокировка цикла событий</h3><p>Длительный синхронный код (например, тяжёлые циклы, сложные вычисления) мешает циклу событий обрабатывать другие задачи. Ваш интерфейс зависает, а другие обратные вызовы задерживаются.</p><p><strong>Решение:</strong> Разбивайте тяжёлую работу на более мелкие части с помощью <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> или переносите её в веб-воркеры (браузер) / рабочие потоки (Node.js).</p><h3></h3><h3>Забывание приоритета микрозадач</h3><p>Предположение, что <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> выполнится сразу после другого кода, может привести к состояниям гонки.</p><p><strong>Решение:</strong> Понимайте очередь микрозадач. Используйте <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> или <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong>, когда нужно отложить выполнение, но всё же выполнить код до операций ввода-вывода.</p><h3></h3><h3>Бесконечные циклы микрозадач</h3><p>Как показано в примере 2, рекурсивное добавление микрозадач может «заморить голодом» макрозадачи и события рендеринга.</p><p><strong>Решение:</strong> Избегайте неограниченной рекурсии в микрозадачах. Используйте макрозадачу (например, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) для длительной отложенной работы.</p><h3></h3><h3>Смешение внутреннего устройства async/await</h3><p>Функции <strong>async</strong> — это просто синтаксический сахар над промисами. Каждый <strong>await</strong> создаёт продолжение в виде микрозадачи. Знание этого помогает предсказать порядок выполнения.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // граница микрозадачи\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Вывод: 1, 3, 2\r\n</pre><p></p><h2>8. Заключение</h2><p>Цикл событий — это сердце JavaScript. Он позволяет однопоточному языку эффективно обрабатывать асинхронные операции, сохраняя приложения отзывчивыми. Понимая взаимодействие между стеком вызовов, веб-API, очередью макрозадач и очередью микрозадач, вы сможете писать предсказуемый и производительный код.</p><p><strong>Ключевые выводы:</strong></p><ul><li>JavaScript выполняется синхронно в стеке вызовов.</li><li>Асинхронные API делегируют работу окружению (браузер/Node).</li><li>Когда стек пуст, цикл событий перемещает обратные вызовы из очередей в стек.</li><li><strong>Микрозадачи</strong> (промисы, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) имеют более высокий приоритет, чем <strong>макрозадачи</strong> (таймеры, ввод-вывод).</li><li>Цикл событий обрабатывает все микрозадачи перед следующей макрозадачей или рендерингом.</li></ul><p>Освоение цикла событий — это не просто тема для собеседований; это необходимо для отладки, избежания узких мест производительности и истинного понимания того, как JavaScript работает под капотом.</p>', 'De JavaScript Event Loop begrijpen: De complete gids voor beginners en professionals', '<p>JavaScript is overal, van interactieve websites tot server-side applicaties met Node.js. Een van de krachtigste (en vaak verkeerd begrepen) functies van de taal is het vermogen om veel taken tegelijkertijd te verwerken, ondanks dat het <strong>single-threaded</strong> is. Hoe doet het dat? Het geheim is de <strong>event loop</strong>.</p><p></p><p><strong>In deze gids ontraadselen we de JavaScript event loop. Je leert:</strong></p><ul><li>Wat de event loop is en waarom het belangrijk is.</li><li>Hoe de call stack, Web API\'s en callback queues samenwerken.</li><li>Het verschil tussen <strong>microtasks</strong> en <strong>macrotasks</strong>.</li><li>Praktijkvoorbeelden die de event loop in actie laten zien.</li><li>Veelvoorkomende valkuilen en hoe ze te vermijden.</li></ul><p>Aan het einde heb je een stevig begrip van asynchroon JavaScript—essentieel voor debuggen, het schrijven van efficiënte code en het slagen voor technische interviews.</p><p></p><h2>1. De JavaScript runtime-omgeving</h2><p>Om de event loop te begrijpen, hebben we eerst een vogelperspectief nodig van de JavaScript runtime-omgeving (in een browser of Node.js). De belangrijkste componenten zijn:</p><ul><li><strong>Heap</strong> – Waar objecten in het geheugen worden opgeslagen.</li><li><strong>Call Stack</strong> – Een LIFO-structuur (Last In, First Out) die functie-uitvoering bijhoudt.</li><li><strong>Web API\'s / Node API\'s</strong> – Door de browser geleverde functies zoals <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, DOM-gebeurtenissen, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong>, of Node.js\'s <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong>-module. Ze draaien buiten de hoofdthread.</li><li><strong>Callback Queue</strong> (ook wel Task Queue genoemd) – Bevat callbacks van Web API\'s die klaar zijn om uitgevoerd te worden.</li><li><strong>Microtask Queue</strong> – Een speciale wachtrij voor promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> en <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Event Loop</strong> – De orkestrator die callbacks van wachtrijen naar de call stack verplaatst wanneer de stack leeg is.</li></ul><p></p><p></p><blockquote>? <strong>Opmerking:</strong> De JavaScript-engine zelf (zoals V8) <strong>bevat niet</strong> de Web API\'s of de event loop. Ze worden geleverd door de browser of Node.js-omgeving.</blockquote><p></p><h2>2. De Call Stack – Synchrone uitvoering</h2><p>De call stack is waar je code regel voor regel wordt uitgevoerd. Wanneer je een functie aanroept, wordt deze op de stack geplaatst; wanneer de functie terugkeert, wordt deze van de stack gehaald.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Stap voor stap:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> wordt op de stack geplaatst.</li><li>Binnen <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong> wordt <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> aangeroepen en op de stack geplaatst.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> retourneert, dus wordt van de stack gehaald.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> wordt op de stack geplaatst, uitgevoerd en vervolgens verwijderd.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> eindigt en wordt van de stack gehaald.</li></ul><p>De stack is nu leeg. Simpel, toch? Problemen ontstaan wanneer we iets proberen te doen dat tijd kost, zoals een netwerkverzoek of een timer. Als we synchroon zouden wachten, zou de hele pagina vastlopen. Dat is waar asynchrone API\'s in beeld komen.</p><p></p><h2>3. Asynchroon JavaScript – Uitstappen</h2><p>Wanneer je een asynchrone functie aanroept (bijv. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> of een event listener), blokkeert deze de stack niet. In plaats daarvan nemen de browser of Node.js het over.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Wat er achter de schermen gebeurt:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> wordt uitgevoerd en van de stack gehaald.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> wordt aangeroepen. De callback wordt overgedragen aan de <strong>Web API</strong> (in dit geval een timer). De timer begint op de achtergrond af te tellen, <strong>buiten</strong> de hoofdthread.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> wordt onmiddellijk uitgevoerd.</li><li>Na ongeveer 1000 ms verplaatst de Web API de callback naar de <strong>Callback Queue</strong>.</li><li>De <strong>Event Loop</strong> controleert voortdurend: <em>\"Is de call stack leeg?\"</em> Wanneer dat het geval is, neemt het de eerste callback uit de wachtrij en plaatst deze op de stack voor uitvoering.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> wordt gelogd.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Zelfs als de vertraging 0 ms was <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, zou de callback nog steeds in de wachtrij wachten tot de stack leeg is. Daarom wordt <strong>&quot;End&quot;</strong> altijd vóór <strong>&quot;Timeout&quot;</strong> gelogd.</p><p></p><h2>4. De Event Loop – De eeuwige poortwachter</h2><p>De event loop heeft één simpele taak: <strong>de call stack en de callback queues bewaken</strong>. Als de stack leeg is, neemt het de eerste wachtende callback en plaatst deze op de stack.</p><p>Maar er is een addertje onder het gras—er zijn eigenlijk <strong>twee</strong> soorten wachtrijen: <strong>macrotasks</strong> (of gewoon \"tasks\") en <strong>microtasks</strong>. De event loop behandelt ze anders.</p><p></p><h3>Macrotasks (of Tasks)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), I/O-taken, UI-rendering.</li><li>Elke iteratie van de event loop verwerkt <strong>één</strong> macrotask uit de callback queue.</li></ul><p></p><h3>Microtasks</h3><ul><li>Promises (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Na <strong>elke</strong> macrotask leegt de event loop <strong>de volledige microtask queue</strong> voordat het doorgaat naar de volgende macrotask of rendering.</li></ul><p>Dit prioriteitssysteem is cruciaal. Laten we het in actie zien.</p><p></p><h2>5. Microtasks vs Macrotasks – Wie gaat er eerst?</h2><p></p><p><strong>Beschouw deze code:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Uitvoer:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Stap-voor-stap uitleg:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> wordt uitgevoerd, stack wordt leeg.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – de callback wordt overgedragen aan de Web API (timer met 0 ms). Na 0 ms wordt deze naar de <strong>macrotask queue</strong> verplaatst.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – de <code>then</code>-callback is een <strong>microtask</strong>. Deze wordt in de microtask queue geplaatst.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> wordt onmiddellijk uitgevoerd.</p><p>De call stack is nu leeg.</p><p><strong>Microtask-checkpoint:</strong> Voordat een macrotask wordt genomen, leegt de event loop de microtask queue. Dus <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span> wordt uitgevoerd, dan plant de tweede <code>then</code> een andere microtask, die ook meteen wordt uitgevoerd. <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span> wordt gelogd.</p><p>Microtask queue is leeg. Nu neemt de event loop de volgende macrotask uit de wachtrij – de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>-callback. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> wordt gelogd.</p><p>Dit verklaart waarom promises timers kunnen \"voorspringen\", zelfs als de timervertraging nul is.</p><p></p><h2>6. Praktische voorbeelden die de event loop verduidelijken</h2><h3>Voorbeeld 1: Gemengde timers en promises</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Uitvoer: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Voorbeeld 2: Recursieve microtasks</h3><p>Wat gebeurt er als je microtasks blijft toevoegen binnen een microtask?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // plant nog een microtask\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Dit zal <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> oneindig loggen, en de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>-callback zal <strong>nooit</strong> worden uitgevoerd omdat de microtask queue nooit leeg raakt. Dit kan de event loop uithongeren – een reëel gevaar als je niet voorzichtig bent.</p><p></p><h3>Voorbeeld 3: Event loop en UI-rendering (browser)</h3><p>In browsers vindt rendering (schilderen) plaats na microtasks en vóór de volgende macrotask. Daarom kun je layout thrashing zien als je herhaaldelijk de DOM wijzigt binnen microtasks.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Deze callback is een macrotask\r\n  Promise.resolve().then(() =&gt; {\r\n    // Deze microtask wordt uitgevoerd vóór de volgende render\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>Wanneer op de knop wordt geklikt, is de volgorde:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (macrotask).</li><li>Alle microtasks (de <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>-callback).</li><li>Dan kan de browser renderen.</li></ul><p></p><h2>7. Veelvoorkomende valkuilen en hoe ze te vermijden</h2><h3>De event loop blokkeren</h3><p>Langlopende synchrone code (bijv. zware loops, complexe berekeningen) voorkomt dat de event loop andere taken verwerkt. Je UI loopt vast en andere callbacks worden vertraagd.</p><p><strong>Oplossing:</strong> Verdeel zwaar werk in kleinere stukken met behulp van <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, of verplaats het naar een Web Worker (browser) / worker threads (Node.js).</p><h3></h3><h3>Microtask-prioriteit vergeten</h3><p>Aannemen dat <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> onmiddellijk na andere code zal worden uitgevoerd, kan leiden tot race conditions.</p><p><strong>Oplossing:</strong> Begrijp de microtask queue. Gebruik <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> of <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> wanneer je moet uitstellen maar toch vóór I/O wilt uitvoeren.</p><h3></h3><h3>Oneindige microtask-lussen</h3><p>Zoals getoond in voorbeeld 2, kan het recursief toevoegen van microtasks macrotasks en render-gebeurtenissen uithongeren.</p><p><strong>Oplossing:</strong> Vermijd onbegrensde recursie in microtasks. Gebruik een macrotask (zoals <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) voor langlopend uitgesteld werk.</p><h3></h3><h3>Async/await-internals mixen</h3><p><strong>async</strong>-functies zijn slechts syntactische suiker bovenop promises. Elke <strong>await</strong> creëert een microtask-vervolg. Dit weten helpt je de uitvoeringsvolgorde te voorspellen.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // microtask-grens\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Uitvoer: 1, 3, 2\r\n</pre><p></p><h2>8. Conclusie</h2><p>De event loop is de hartslag van JavaScript. Het stelt een single-threaded taal in staat om asynchrone bewerkingen efficiënt af te handelen en applicaties responsief te houden. Door de wisselwerking tussen de call stack, Web API\'s, de macrotask queue en de microtask queue te begrijpen, kun je voorspelbare en performante code schrijven.</p><p><strong>Belangrijkste punten:</strong></p><ul><li>JavaScript wordt synchroon uitgevoerd op de call stack.</li><li>Asynchrone API\'s delegeren werk aan de omgeving (browser/Node).</li><li>Wanneer de stack leeg is, verplaatst de event loop callbacks van wachtrijen naar de stack.</li><li><strong>Microtasks</strong> (promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) hebben een hogere prioriteit dan <strong>macrotasks</strong> (timers, I/O).</li><li>De event loop verwerkt alle microtasks vóór de volgende macrotask of render.</li></ul><p>De event loop beheersen is niet alleen een interviewonderwerp—het is essentieel voor debuggen, het vermijden van prestatieknelpunten en het echt begrijpen hoe JavaScript onder de motorkap werkt.</p>', 'Förstå JavaScript-händelseloopen: Den kompletta guiden för nybörjare och proffs', '<p>JavaScript finns överallt, från interaktiva webbplatser till serverapplikationer med Node.js. En av de mest kraftfulla (och ofta missförstådda) funktionerna i språket är dess förmåga att hantera många uppgifter samtidigt, trots att det är <strong>enkeltrådat</strong>. Hur går det till? Hemligheten är <strong>händelseloopen</strong>.</p><p></p><p><strong>I den här guiden avmystifierar vi JavaScript-händelseloopen. Du får lära dig:</strong></p><ul><li>Vad händelseloopen är och varför den är viktig.</li><li>Hur anropsstacken, webb-API:er och callback-köer samverkar.</li><li>Skillnaden mellan <strong>microtasks</strong> och <strong>macrotasks</strong>.</li><li>Verkliga exempel som visar händelseloopen i aktion.</li><li>Vanliga fallgropar och hur man undviker dem.</li></ul><p>När du är klar kommer du att ha en gedigen förståelse för asynkron JavaScript – viktigt för felsökning, att skriva effektiv kod och att lyckas på tekniska intervjuer.</p><p></p><h2>1. JavaScripts körningsmiljö</h2><p>För att förstå händelseloopen behöver vi först en översikt över JavaScripts körningsmiljö (i en webbläsare eller Node.js). Huvudkomponenterna är:</p><ul><li><strong>Heap</strong> – Där objekt lagras i minnet.</li><li><strong>Anropsstack (Call Stack)</strong> – En LIFO-struktur (Last In, First Out) som håller reda på funktionsanrop.</li><li><strong>Webb-API:er / Node-API:er</strong> – Webbläsarens funktioner som <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, DOM-händelser, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> eller Node.js <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong>-modul. De körs utanför huvudtråden.</li><li><strong>Callback-kö</strong> (även kallad Task Queue) – Innehåller callbacks från webb-API:er som är redo att köras.</li><li><strong>Microtask-kö</strong> – En speciell kö för promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> och <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Händelseloop (Event Loop)</strong> – Orkesteraren som flyttar callbacks från köerna till anropsstacken när stacken är tom.</li></ul><p></p><p></p><blockquote>? <strong>Obs:</strong> JavaScript-motorn i sig (som V8) <strong>inkluderar inte</strong> webb-API:er eller händelseloopen. De tillhandahålls av webbläsaren eller Node.js-miljön.</blockquote><p></p><h2>2. Anropsstacken – Synkron exekvering</h2><p>Anropsstacken är där din kod körs rad för rad. När du anropar en funktion läggs den på stacken; när funktionen returnerar tas den bort från stacken.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Steg för steg:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> läggs på stacken.</li><li>Inuti <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong> anropas <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> och läggs på stacken.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> returnerar, så den tas bort från stacken.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> läggs på stacken, körs och tas bort.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> avslutas och tas bort.</li></ul><p>Stacken är nu tom. Enkelt, eller hur? Problem uppstår när vi försöker göra något som tar tid, som en nätverksbegäran eller en timer. Om vi väntade synkront skulle hela sidan frysa. Det är här asynkrona API:er kommer in.</p><p></p><h2>3. Asynkron JavaScript – Kliva ur</h2><p>När du anropar en asynkron funktion (t.ex. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> eller en händelseavlyssnare) blockerar den inte stacken. Istället tar webbläsaren eller Node.js över.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Vad som händer bakom kulisserna:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> körs och tas bort från stacken.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> anropas. Dess callback överlämnas till <strong>webb-API:et</strong> (en timer i detta fall). Timern börjar räkna ner i bakgrunden, <strong>utanför</strong> huvudtråden.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> körs omedelbart.</li><li>Efter cirka 1000 ms flyttar webb-API:et callbacken till <strong>callback-kön</strong>.</li><li><strong>Händelseloopen</strong> kontrollerar ständigt: <em>”Är anropsstacken tom?”</em> När den är det tar den första callbacken från kön och lägger den på stacken för exekvering.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> loggas.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Även om fördröjningen vore 0 ms <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, skulle callbacken fortfarande vänta i kön tills stacken är tom. Därför loggas <strong>&quot;End&quot;</strong> alltid före <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. Händelseloopen – Den evige väktaren</h2><p>Händelseloopen har en enkel uppgift: <strong>övervaka anropsstacken och callback-köerna</strong>. Om stacken är tom tar den första väntande callbacken och lägger den på stacken.</p><p>Men det finns en twist – det finns faktiskt <strong>två</strong> typer av köer: <strong>macrotasks</strong> (eller bara ”tasks”) och <strong>microtasks</strong>. Händelseloopen hanterar dem olika.</p><p></p><h3>Macrotasks (eller Tasks)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), I/O-uppgifter, UI-rendering.</li><li>Varje iteration av händelseloopen bearbetar <strong>en</strong> macrotask från callback-kön.</li></ul><p></p><h3>Microtasks</h3><ul><li>Promises (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Efter <strong>varje</strong> macrotask tömmer händelseloopen <strong>hela microtask-kön</strong> innan den går vidare till nästa macrotask eller rendering.</li></ul><p>Detta prioriteringssystem är avgörande. Låt oss se det i aktion.</p><p></p><h2>5. Microtasks vs Macrotasks – Vem går först?</h2><p></p><p><strong>Betrakta den här koden:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Utdata:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Steg-för-steg-förklaring:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> körs, stacken töms.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – callbacken överlämnas till webb-API:et (timer med 0 ms). Efter 0 ms flyttas den till <strong>macrotask-kön</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – <code>then</code>-callbacken är en <strong>microtask</strong>. Den placeras i microtask-kön.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> körs omedelbart.</p><p>Anropsstacken är nu tom.</p><p><strong>Microtask-kontrollpunkt:</strong> Innan den tar någon macrotask tömmer händelseloopen microtask-kön. Så <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span> körs, sedan schemalägger den andra <code>then</code> en microtask, som också körs omedelbart. <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span> loggas.</p><p>Microtask-kön är tom. Nu tar händelseloopen nästa macrotask från kön – <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>-callbacken. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> loggas.</p><p>Detta förklarar varför promises kan ”hoppa före” timers, även om timerfördröjningen är noll.</p><p></p><h2>6. Praktiska exempel som klargör händelseloopen</h2><h3>Exempel 1: Blandade timers och promises</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Utdata: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Exempel 2: Rekursiva microtasks</h3><p>Vad händer om du fortsätter lägga till microtasks inuti en microtask?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // schemalägger en ny microtask\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Detta kommer att logga <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> oändligt, och <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>-callbacken <strong>kommer aldrig</strong> att köras eftersom microtask-kön aldrig töms. Detta kan svälta händelseloopen – en verklig fara om man inte är försiktig.</p><p></p><h3>Exempel 3: Händelseloopen och UI-rendering (webbläsare)</h3><p>I webbläsare sker rendering (målning) efter microtasks och före nästa macrotask. Därför kan du se layout-thrashing om du upprepade gånger ändrar DOM inuti microtasks.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Denna callback är en macrotask\r\n  Promise.resolve().then(() =&gt; {\r\n    // Denna microtask körs före nästa rendering\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>När knappen klickas är ordningen:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (macrotask).</li><li>Alla microtasks (<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>-callbacken).</li><li>Sedan kan webbläsaren rendera.</li></ul><p></p><h2>7. Vanliga fallgropar och hur man undviker dem</h2><h3>Blockera händelseloopen</h3><p>Långvarig synkron kod (t.ex. tunga loopar, komplexa beräkningar) hindrar händelseloopen från att bearbeta andra uppgifter. Ditt UI fryser och andra callbacks försenas.</p><p><strong>Lösning:</strong> Dela upp tungt arbete i mindre bitar med hjälp av <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, eller flytta det till en Web Worker (webbläsare) / worker-trådar (Node.js).</p><h3></h3><h3>Glömma microtasks prioritet</h3><p>Att anta att <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> kommer att köras omedelbart efter annan kod kan leda till race conditions.</p><p><strong>Lösning:</strong> Förstå microtask-kön. Använd <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> eller <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> när du behöver skjuta upp men ändå köra före I/O.</p><h3></h3><h3>Oändliga microtask-loopar</h3><p>Som visas i exempel 2 kan rekursivt tillägg av microtasks svälta macrotasks och renderingshändelser.</p><p><strong>Lösning:</strong> Undvik obegränsad rekursion i microtasks. Använd en macrotask (som <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) för långvarigt uppskjutet arbete.</p><h3></h3><h3>Blanda async/await-interna</h3><p><strong>async</strong>-funktioner är bara syntaktiskt socker över promises. Varje <strong>await</strong> skapar en microtask-fortsättning. Att veta detta hjälper dig att förutsäga exekveringsordningen.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // microtask-gräns\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Utdata: 1, 3, 2\r\n</pre><p></p><h2>8. Slutsats</h2><p>Händelseloopen är hjärtat i JavaScript. Den gör att ett enkeltrådat språk kan hantera asynkrona operationer effektivt och hålla applikationer responsiva. Genom att förstå samspelet mellan anropsstacken, webb-API:er, macrotask-kön och microtask-kön kan du skriva förutsägbar och prestandastark kod.</p><p><strong>Viktiga slutsatser:</strong></p><ul><li>JavaScript körs synkront på anropsstacken.</li><li>Asynkrona API:er delegerar arbete till miljön (webbläsare/Node).</li><li>När stacken är tom flyttar händelseloopen callbacks från köerna till stacken.</li><li><strong>Microtasks</strong> (promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) har högre prioritet än <strong>macrotasks</strong> (timers, I/O).</li><li>Händelseloopen bearbetar alla microtasks före nästa macrotask eller rendering.</li></ul><p>Att behärska händelseloopen är inte bara ett intervjuämne – det är viktigt för felsökning, att undvika prestandaflaskhalsar och att verkligen förstå hur JavaScript fungerar under huven.</p>', 'JavaScript Olay Döngüsünü Anlamak: Yeni Başlayanlar ve Profesyoneller için Eksiksiz Kılavuz', '<p>JavaScript etkileşimli web sitelerinden Node.js ile sunucu taraflı uygulamalara kadar her yerde. Dilin en güçlü (ve çoğu zaman yanlış anlaşılan) özelliklerinden biri, <strong>tek iş parçacıklı</strong> olmasına rağmen birçok görevi aynı anda yapabiliyormuş gibi görünmesidir. Bunu nasıl başarıyor? Sır <strong>olay döngüsünde</strong>.</p><p></p><p><strong>Bu kılavuzda JavaScript olay döngüsünü açıklığa kavuşturacağız. Öğrenecekleriniz:</strong></p><ul><li>Olay döngüsü nedir ve neden önemlidir?</li><li>Çağrı yığını, Web API\'leri ve geri çağırma kuyrukları nasıl birlikte çalışır?</li><li><strong>Mikrogörevler</strong> ve <strong>makrogörevler</strong> arasındaki fark.</li><li>Olay döngüsünü eylem halinde gösteren gerçek dünya örnekleri.</li><li>Yaygın tuzaklar ve bunlardan nasıl kaçınılır.</li></ul><p>Sonunda, hata ayıklama, verimli kod yazma ve teknik mülakatlarda başarılı olma için gerekli olan asenkron JavaScript\'i sağlam bir şekilde kavrayacaksınız.</p><p></p><h2>1. JavaScript Çalışma Zamanı Ortamı</h2><p>Olay döngüsünü anlamak için önce JavaScript çalışma zamanı ortamına (bir tarayıcı veya Node.js\'de) kuşbakışı bakmamız gerekir. Ana bileşenler şunlardır:</p><ul><li><strong>Yığın (Heap)</strong> – Nesnelerin bellekte depolandığı yer.</li><li><strong>Çağrı Yığını (Call Stack)</strong> – Fonksiyon yürütmesini izleyen bir LIFO (Son Giren İlk Çıkar) yapısı.</li><li><strong>Web API\'leri / Node API\'leri</strong> – Tarayıcı tarafından sağlanan <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, DOM olayları, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> veya Node.js\'in <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> modülü gibi özellikler. Ana iş parçacığının dışında çalışırlar.</li><li><strong>Geri Çağırma Kuyruğu</strong> (Görev Kuyruğu olarak da adlandırılır) – Çalıştırılmaya hazır Web API\'lerinden gelen geri çağırmaları tutar.</li><li><strong>Mikrogörev Kuyruğu</strong> – Promises, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> ve <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> için özel bir kuyruk.</li><li><strong>Olay Döngüsü</strong> – Yığın boşaldığında geri çağırmaları kuyruklardan çağrı yığınına taşıyan orkestratör.</li></ul><p></p><p></p><blockquote>? <strong>Not:</strong> JavaScript motorunun kendisi (V8 gibi) Web API\'lerini veya olay döngüsünü <strong>içermez</strong>. Bunlar tarayıcı veya Node.js ortamı tarafından sağlanır.</blockquote><p></p><h2>2. Çağrı Yığını – Senkron Yürütme</h2><p>Çağrı yığını, kodunuzun satır satır çalıştığı yerdir. Bir işlevi çağırdığınızda, yığına eklenir; işlev geri döndüğünde, yığından çıkarılır.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Adım adım:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> yığına eklenir.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong> içinde <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> çağrılır ve yığına eklenir.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> geri döner, bu nedenle yığından çıkarılır.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> yığına eklenir, çalıştırılır ve ardından çıkarılır.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> biter ve yığından çıkarılır.</li></ul><p>Yığın şimdi boş. Basit, değil mi? Ağ isteği veya zamanlayıcı gibi zaman alan bir şey yapmaya çalıştığımızda sorunlar ortaya çıkar. Senkron olarak bekleseydik, sayfanın tamamı donardı. Asenkron API\'lerin devreye girdiği yer burasıdır.</p><p></p><h2>3. Asenkron JavaScript – Dışarı Adım Atmak</h2><p>Asenkron bir işlev çağırdığınızda (örneğin <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> veya bir olay dinleyicisi), yığını engellemez. Bunun yerine, tarayıcı veya Node.js devralır.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Sahne arkasında neler oluyor:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> çalışır ve yığından çıkarılır.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> çağrılır. Geri çağırması <strong>Web API\'sine</strong> (bu durumda bir zamanlayıcı) teslim edilir. Zamanlayıcı arka planda, <strong>ana iş parçacığının dışında</strong> geri saymaya başlar.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> hemen çalışır.</li><li>Yaklaşık 1000 ms sonra, Web API geri çağırmayı <strong>geri çağırma kuyruğuna</strong> taşır.</li><li><strong>Olay döngüsü</strong> sürekli kontrol eder: <em>\"Çağrı yığını boş mu?\"</em> Boş olduğunda, kuyruktaki ilk geri çağırmayı alır ve çalıştırılmak üzere yığına ekler.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> kaydedilir.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Gecikme 0 ms olsa bile <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, geri çağırma yığın boşalana kadar kuyrukta bekler. Bu nedenle <strong>&quot;End&quot;</strong> her zaman <strong>&quot;Timeout&quot;</strong>dan önce kaydedilir.</p><p></p><h2>4. Olay Döngüsü – Ebedi Bekçi</h2><p>Olay döngüsünün basit bir işi vardır: <strong>çağrı yığınını ve geri çağırma kuyruklarını izlemek</strong>. Yığın boşsa, bekleyen ilk geri çağırmayı alır ve yığına ekler.</p><p>Ama bir püf noktası var – aslında <strong>iki</strong> tür kuyruk vardır: <strong>makrogörevler</strong> (veya sadece \"görevler\") ve <strong>mikrogörevler</strong>. Olay döngüsü bunları farklı şekilde işler.</p><p></p><h3>Makrogörevler (veya Görevler)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), G/Ç görevleri, UI oluşturma.</li><li>Olay döngüsünün her yinelemesi, geri çağırma kuyruğundan <strong>bir</strong> makrogörev işler.</li></ul><p></p><h3>Mikrogörevler</h3><ul><li>Promises (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Her</strong> makrogörevden sonra, olay döngüsü bir sonraki makrogöreve veya oluşturmaya geçmeden önce <strong>mikrogörev kuyruğunun tamamını boşaltır</strong>.</li></ul><p>Bu öncelik sistemi çok önemlidir. Şimdi onu eylemde görelim.</p><p></p><h2>5. Mikrogörevler vs Makrogörevler – Hangisi Önce Gelir?</h2><p></p><p><strong>Bu kodu düşünün:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Çıktı:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Adım adım açıklama:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> çalışır, yığın boşalır.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – geri çağırma Web API\'sine (0 ms zamanlayıcı) teslim edilir. 0 ms sonra, <strong>makrogörev kuyruğuna</strong> taşınır.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – <code>then</code> geri çağırması bir <strong>mikrogörevdir</strong>. Mikrogörev kuyruğuna yerleştirilir.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> hemen çalışır.</p><p>Çağrı yığını artık boş.</p><p><strong>Mikrogörev kontrol noktası:</strong> Herhangi bir makrogörevi almadan önce, olay döngüsü mikrogörev kuyruğunu boşaltır. Böylece <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span> çalışır, ardından ikinci <code>then</code> başka bir mikrogörev planlar ve o da hemen çalışır. <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span> kaydedilir.</p><p>Mikrogörev kuyruğu boş. Şimdi olay döngüsü kuyruktaki bir sonraki makrogörevi alır – <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> geri çağırması. <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong> kaydedilir.</p><p>Bu, zamanlayıcı gecikmesi sıfır olsa bile neden promiselerin zamanlayıcıların \"önüne geçebildiğini\" açıklar.</p><p></p><h2>6. Olay Döngüsünü Açıklayan Pratik Örnekler</h2><h3>Örnek 1: Karışık Zamanlayıcılar ve Promiseler</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Çıktı: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Örnek 2: Özyinelemeli Mikrogörevler</h3><p>Bir mikrogörev içinde mikrogörev eklemeye devam ederseniz ne olur?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // başka bir mikrogörev planlar\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Bu, <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code> sonsuza kadar kaydeder ve <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> geri çağırması <strong>asla</strong> çalışmaz çünkü mikrogörev kuyruğu asla boşalmaz. Bu, olay döngüsünü aç bırakabilir – dikkatli olunmazsa gerçek bir tehlike.</p><p></p><h3>Örnek 3: Olay Döngüsü ve UI Oluşturma (Tarayıcı)</h3><p>Tarayıcılarda oluşturma (boyama) mikrogörevlerden sonra ve bir sonraki makrogörevden önce gerçekleşir. Bu nedenle, mikrogörevler içinde DOM\'u tekrar tekrar değiştirirseniz düzen sorunları görebilirsiniz.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Bu geri çağırma bir makrogörevdir\r\n  Promise.resolve().then(() =&gt; {\r\n    // Bu mikrogörev bir sonraki oluşturmadan önce çalışır\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>Düğmeye tıklandığında sıralama şöyledir:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (makrogörev).</li><li>Tüm mikrogörevler (<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong> geri çağırması).</li><li>Ardından tarayıcı oluşturma yapabilir.</li></ul><p></p><h2>7. Yaygın Tuzaklar ve Bunlardan Kaçınma Yolları</h2><h3>Olay Döngüsünü Engellemek</h3><p>Uzun süren senkron kod (örneğin ağır döngüler, karmaşık hesaplamalar), olay döngüsünün diğer görevleri işlemesini engeller. UI\'nız donar ve diğer geri çağırmalar gecikir.</p><p><strong>Çözüm:</strong> Ağır işi <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> kullanarak daha küçük parçalara bölün veya bir Web Worker\'a (tarayıcı) / worker iş parçacıklarına (Node.js) taşıyın.</p><h3></h3><h3>Mikrogörev Önceliğini Unutmak</h3><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong>\'ın diğer koddan hemen sonra çalışacağını varsaymak yarış koşullarına yol açabilir.</p><p><strong>Çözüm:</strong> Mikrogörev kuyruğunu anlayın. Ertelemek ancak yine de G/Ç\'den önce çalıştırmak istediğinizde <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> veya <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong> kullanın.</p><h3></h3><h3>Sonsuz Mikrogörev Döngüleri</h3><p>Örnek 2\'de gösterildiği gibi, özyinelemeli olarak mikrogörev eklemek makrogörevleri ve oluşturma olaylarını aç bırakabilir.</p><p><strong>Çözüm:</strong> Mikrogörevlerde sınırsız özyinelemeden kaçının. Uzun süren ertelenmiş işler için bir makrogörev (<strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> gibi) kullanın.</p><h3></h3><h3>Async/Await İç Yapısını Karıştırmak</h3><p><strong>async</strong> işlevleri, promiseler üzerinde sadece sözdizimsel şekerdir. Her <strong>await</strong> bir mikrogörev devamı oluşturur. Bunu bilmek, yürütme sırasını tahmin etmenize yardımcı olur.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // mikrogörev sınırı\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Çıktı: 1, 3, 2\r\n</pre><p></p><h2>8. Sonuç</h2><p>Olay döngüsü JavaScript\'in kalp atışıdır. Tek iş parçacıklı bir dilin asenkron işlemleri verimli bir şekilde ele almasına ve uygulamaları duyarlı tutmasına olanak tanır. Çağrı yığını, Web API\'leri, makrogörev kuyruğu ve mikrogörev kuyruğu arasındaki etkileşimi anlayarak öngörülebilir ve yüksek performanslı kod yazabilirsiniz.</p><p><strong>Anahtar çıkarımlar:</strong></p><ul><li>JavaScript çağrı yığınında senkron olarak çalışır.</li><li>Asenkron API\'ler işi ortama (tarayıcı/Node) devreder.</li><li>Yığın boş olduğunda, olay döngüsü geri çağırmaları kuyruklardan yığına taşır.</li><li><strong>Mikrogörevler</strong> (promiseler, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) <strong>makrogörevlerden</strong> (zamanlayıcılar, G/Ç) daha yüksek önceliğe sahiptir.</li><li>Olay döngüsü, bir sonraki makrogörev veya oluşturmadan önce tüm mikrogörevleri işler.</li></ul><p>Olay döngüsünde ustalaşmak sadece bir mülakat konusu değildir – hata ayıklama, performans darboğazlarından kaçınma ve JavaScript\'in perde arkasında nasıl çalıştığını gerçekten anlamak için gereklidir.</p>', 'Розуміння циклу подій JavaScript: Повний посібник для початківців та професіоналів', '<p>JavaScript є всюди: від інтерактивних веб-сайтів до серверних додатків на Node.js. Однією з найпотужніших (і часто неправильно зрозумілих) особливостей мови є її здатність одночасно обробляти багато завдань, незважаючи на те, що вона <strong>однопотокова</strong>. Як їй це вдається? Секрет криється в <strong>циклі подій</strong>.</p><p></p><p><strong>У цьому посібнику ми розберемося в циклі подій JavaScript. Ви дізнаєтесь:</strong></p><ul><li>Що таке цикл подій і чому він важливий.</li><li>Як стек викликів, веб-API та черги зворотних викликів працюють разом.</li><li>Різницю між <strong>мікрозавданнями</strong> та <strong>макрозавданнями</strong>.</li><li>Реальні приклади, які демонструють цикл подій у дії.</li><li>Поширені помилки та способи їх уникнення.</li></ul><p>У підсумку ви отримаєте міцне розуміння асинхронного JavaScript — необхідного для налагодження, написання ефективного коду та успішного проходження технічних співбесід.</p><p></p><h2>1. Середовище виконання JavaScript</h2><p>Щоб зрозуміти цикл подій, спочатку потрібно поглянути на середовище виконання JavaScript (у браузері або Node.js). Основні компоненти:</p><ul><li><strong>Куча</strong> – місце зберігання об\'єктів у пам\'яті.</li><li><strong>Стек викликів</strong> – структура LIFO (останнім прийшов — першим вийшов), яка відстежує виконання функцій.</li><li><strong>Веб-API / Node API</strong> – функції, що надаються браузером, такі як <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, події DOM, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> або модуль <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fs</strong> у Node.js. Вони виконуються поза основним потоком.</li><li><strong>Черга зворотних викликів</strong> (також називається чергою завдань) – містить зворотні виклики від веб-API, готові до виконання.</li><li><strong>Черга мікрозавдань</strong> – спеціальна черга для промісів, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">MutationObserver</strong> та <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li><strong>Цикл подій</strong> – координатор, який переміщує зворотні виклики з черг до стеку викликів, коли стек порожній.</li></ul><p></p><p></p><blockquote>? <strong>Примітка:</strong> Сам рушій JavaScript (наприклад, V8) <strong>не включає</strong> веб-API або цикл подій. Вони надаються браузером або середовищем Node.js.</blockquote><p></p><h2>2. Стек викликів – синхронне виконання</h2><p>Стек викликів — це місце, де ваш код виконується рядок за рядком. Коли ви викликаєте функцію, вона поміщається в стек; коли функція повертає результат, вона вилучається зі стеку.</p><p></p><pre data-language=\"javascript\">\r\nfunction greet() {\r\n  return &quot;Hello!&quot;;\r\n}\r\n\r\nfunction sayHello() {\r\n  console.log(greet());\r\n}\r\n\r\nsayHello();\r\n</pre><p></p><p><strong>Крок за кроком:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> поміщається в стек.</li><li>Всередині <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello</strong> викликається <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> і поміщається в стек.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">greet()</strong> повертає результат, тому вилучається зі стеку.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log()</strong> поміщається в стек, виконується, потім вилучається.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">sayHello()</strong> завершується і вилучається.</li></ul><p>Тепер стек порожній. Просто, правда? Проблеми виникають, коли ми намагаємося зробити щось, що потребує часу, наприклад мережевий запит або таймер. Якби ми чекали синхронно, вся сторінка завмерла б. Ось тут і вступають у гру асинхронні API.</p><p></p><h2>3. Асинхронний JavaScript – вихід за межі потоку</h2><p>Коли ви викликаєте асинхронну функцію (наприклад, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">fetch</strong> або обробник подій), вона не блокує стек. Натомість управління передається браузеру або Node.js.</p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 1000);\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Що відбувається за лаштунками:</strong></p><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> виконується і вилучається.</li><li>Викликається <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. Його зворотний виклик передається <strong>веб-API</strong> (у цьому випадку таймеру). Таймер починає зворотний відлік у фоновому режимі, <strong>поза</strong> основним потоком.</li><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> виконується негайно.</li><li>Приблизно через 1000 мс веб-API переміщує зворотний виклик до <strong>черги зворотних викликів</strong>.</li><li><strong>Цикл подій</strong> постійно перевіряє: <em>«Чи стек викликів порожній?»</em> Коли він порожній, цикл бере перший зворотний виклик з черги і поміщає його в стек для виконання.</li><li>Виводиться <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</li></ul><p></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nTimeout\r\n</pre><p></p><p>Навіть якби затримка становила 0 мс <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">(setTimeout(..., 0))</strong>, зворотний виклик все одно чекав би в черзі, поки стек не звільниться. Ось чому <strong>&quot;End&quot;</strong> завжди виводиться раніше за <strong>&quot;Timeout&quot;</strong>.</p><p></p><h2>4. Цикл подій – вічний страж</h2><p>У циклу подій одне просте завдання: <strong>стежити за стеком викликів та чергами зворотних викликів</strong>. Якщо стек порожній, він бере перший очікувальний зворотний виклик і поміщає його в стек.</p><p>Але є нюанс — насправді існують <strong>два</strong> типи черг: <strong>макрозавдання</strong> (або просто «завдання») і <strong>мікрозавдання</strong>. Цикл подій обробляє їх по-різному.</p><p></p><h3>Макрозавдання (або завдання)</h3><ul><li><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setInterval</strong>, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setImmediate</strong> (Node.js), завдання введення-виведення, рендеринг інтерфейсу.</li><li>Кожна ітерація циклу подій обробляє <strong>одне</strong> макрозавдання з черги зворотних викликів.</li></ul><p></p><h3>Мікрозавдання</h3><ul><li>Проміси (<strong class=\"ql-font-monospace\">then</strong>, <strong class=\"ql-font-monospace\">catch</strong>, <strong class=\"ql-font-monospace\">finally</strong>), <strong class=\"ql-font-monospace\">async/await</strong>, <strong class=\"ql-font-monospace\">MutationObserver</strong>, <strong class=\"ql-font-monospace\">queueMicrotask</strong>.</li><li>Після <strong>кожного</strong> макрозавдання цикл подій очищає <strong>всю чергу мікрозавдань</strong>, перш ніж перейти до наступного макрозавдання або рендерингу.</li></ul><p>Ця система пріоритетів є критично важливою. Давайте подивимося на неї в дії.</p><p></p><h2>5. Мікрозавдання проти макрозавдань – хто перший?</h2><p></p><p><strong>Розглянемо цей код:</strong></p><p></p><pre data-language=\"javascript\">\r\nconsole.log(&quot;Start&quot;);\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Timeout&quot;);\r\n}, 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 1&quot;);\r\n  })\r\n  .then(() =&gt; {\r\n    console.log(&quot;Promise 2&quot;);\r\n  });\r\n\r\nconsole.log(&quot;End&quot;);\r\n</pre><p></p><p><strong>Вивід:</strong></p><pre data-language=\"plain\">\r\nStart\r\nEnd\r\nPromise 1\r\nPromise 2\r\nTimeout\r\n</pre><p></p><p><strong>Покрокове пояснення:</strong></p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;Start&quot;)</strong> виконується, стек очищається.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> – зворотний виклик передається веб-API (таймер з 0 мс). Через 0 мс він переміщується до <strong>черги макрозавдань</strong>.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve().then(...)</strong> – зворотний виклик <code>then</code> є <strong>мікрозавданням</strong>. Він поміщається в чергу мікрозавдань.</p><p><strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">console.log(&quot;End&quot;)</strong> виконується негайно.</p><p>Стек викликів тепер порожній.</p><p><strong>Контрольна точка мікрозавдань:</strong> Перш ніж взяти будь-яке макрозавдання, цикл подій очищає чергу мікрозавдань. Таким чином, виконується <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 1</span>, потім другий <code>then</code> планує ще одне мікрозавдання, яке також виконується негайно. Виводиться <span style=\"color: rgb(230, 0, 0);\" class=\"ql-font-monospace\">Promise 2</span>.</p><p>Черга мікрозавдань порожня. Тепер цикл подій бере наступне макрозавдання з черги – зворотний виклик <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>. Виводиться <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">&quot;Timeout&quot;</strong>.</p><p>Це пояснює, чому проміси можуть «обганяти» таймери, навіть якщо затримка таймера дорівнює нулю.</p><p></p><h2>6. Практичні приклади, що пояснюють цикл подій</h2><h3>Приклад 1: Змішані таймери та проміси</h3><p></p><pre data-language=\"javascript\">\r\nconsole.log(1);\r\n\r\nsetTimeout(() =&gt; console.log(2), 0);\r\n\r\nPromise.resolve()\r\n  .then(() =&gt; console.log(3))\r\n  .then(() =&gt; console.log(4));\r\n\r\nconsole.log(5);\r\n\r\n// Вивід: 1, 5, 3, 4, 2\r\n</pre><p></p><h3>Приклад 2: Рекурсивні мікрозавдання</h3><p>Що станеться, якщо ви будете додавати мікрозавдання всередині мікрозавдання?</p><p></p><pre data-language=\"javascript\">\r\nfunction loopMicrotasks() {\r\n  queueMicrotask(() =&gt; {\r\n    console.log(&quot;Microtask running&quot;);\r\n    loopMicrotasks(); // планує ще одне мікрозавдання\r\n  });\r\n}\r\n\r\nsetTimeout(() =&gt; {\r\n  console.log(&quot;Macrotask finally runs&quot;);\r\n}, 0);\r\n\r\nloopMicrotasks();\r\n</pre><p></p><p>Цей код буде нескінченно виводити <code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Microtask&nbsp;running&quot;</strong></code>, і зворотний виклик <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> <strong>ніколи</strong> не виконається, тому що черга мікрозавдань ніколи не спорожніє. Це може «заморити голодом» цикл подій – реальна небезпека, якщо не бути обережним.</p><p></p><h3>Приклад 3: Цикл подій та рендеринг інтерфейсу (браузер)</h3><p>У браузерах рендеринг (малювання) відбувається після мікрозавдань і перед наступним макрозавданням. Ось чому ви можете спостерігати «thrashing» (часті перемальовування) макету, якщо багаторазово змінювати DOM всередині мікрозавдань.</p><p></p><pre data-language=\"javascript\">\r\nbutton.addEventListener(&quot;click&quot;, () =&gt; {\r\n  // Цей зворотний виклик — макрозавдання\r\n  Promise.resolve().then(() =&gt; {\r\n    // Це мікрозавдання виконується до наступного рендерингу\r\n    console.log(&quot;Microtask&quot;);\r\n  });\r\n  console.log(&quot;Click handler&quot;);\r\n});\r\n</pre><p></p><p>При натисканні на кнопку порядок такий:</p><ul><li><code style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\"><strong>&quot;Click&nbsp;handler&quot;</strong></code> (макрозавдання).</li><li>Всі мікрозавдання (зворотний виклик <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">then</strong>).</li><li>Потім браузер може виконати рендеринг.</li></ul><p></p><h2>7. Поширені помилки та способи їх уникнення</h2><h3>Блокування циклу подій</h3><p>Тривалий синхронний код (наприклад, важкі цикли, складні обчислення) заважає циклу подій обробляти інші завдання. Ваш інтерфейс зависає, а інші зворотні виклики затримуються.</p><p><strong>Рішення:</strong> Розбивайте важку роботу на менші частини за допомогою <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong> або переносьте її у веб-воркери (браузер) / робочі потоки (Node.js).</p><h3></h3><h3>Забування пріоритету мікрозавдань</h3><p>Припущення, що <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout(..., 0)</strong> виконається одразу після іншого коду, може призвести до стану гонки.</p><p><strong>Рішення:</strong> Розумійте чергу мікрозавдань. Використовуйте <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong> або <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">Promise.resolve()</strong>, коли потрібно відкласти виконання, але все ж виконати код до операцій введення-виведення.</p><h3></h3><h3>Нескінченні цикли мікрозавдань</h3><p>Як показано в прикладі 2, рекурсивне додавання мікрозавдань може «заморити голодом» макрозавдання та події рендерингу.</p><p><strong>Рішення:</strong> Уникайте необмеженої рекурсії в мікрозавданнях. Використовуйте макрозавдання (наприклад, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">setTimeout</strong>) для тривалої відкладеної роботи.</p><h3></h3><h3>Змішування внутрішньої будови async/await</h3><p>Функції <strong>async</strong> — це просто синтаксичний цукор над промісами. Кожен <strong>await</strong> створює продовження у вигляді мікрозавдання. Знання цього допомагає передбачити порядок виконання.</p><p></p><pre data-language=\"javascript\">\r\nasync function test() {\r\n  console.log(1);\r\n  await null; // межа мікрозавдання\r\n  console.log(2);\r\n}\r\n\r\ntest();\r\nconsole.log(3);\r\n// Вивід: 1, 3, 2\r\n</pre><p></p><h2>8. Висновок</h2><p>Цикл подій — це серце JavaScript. Він дозволяє однопотоковій мові ефективно обробляти асинхронні операції, зберігаючи додатки чуйними. Розуміючи взаємодію між стеком викликів, веб-API, чергою макрозавдань та чергою мікрозавдань, ви зможете писати передбачуваний та продуктивний код.</p><p><strong>Ключові висновки:</strong></p><ul><li>JavaScript виконується синхронно в стеку викликів.</li><li>Асинхронні API делегують роботу середовищу (браузер/Node).</li><li>Коли стек порожній, цикл подій переміщує зворотні виклики з черг до стеку.</li><li><strong>Мікрозавдання</strong> (проміси, <strong style=\"background-color: rgb(250, 204, 204);\" class=\"ql-font-monospace\">queueMicrotask</strong>) мають вищий пріоритет, ніж <strong>макрозавдання</strong> (таймери, введення-виведення).</li><li>Цикл подій обробляє всі мікрозавдання перед наступним макрозавданням або рендерингом.</li></ul><p>Оволодіння циклом подій — це не просто тема для співбесід; це необхідно для налагодження, уникнення вузьких місць продуктивності та справжнього розуміння того, як JavaScript працює під капотом.</p>');

-- --------------------------------------------------------

--
-- Table structure for table `comments`
--

CREATE TABLE `comments` (
  `id` int(11) NOT NULL,
  `blog_id` int(11) NOT NULL,
  `username` varchar(100) NOT NULL,
  `email` varchar(255) NOT NULL,
  `comment` text NOT NULL,
  `status` enum('pending','published','declined') DEFAULT 'pending',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Dumping data for table `comments`
--

INSERT INTO `comments` (`id`, `blog_id`, `username`, `email`, `comment`, `status`, `created_at`) VALUES
(3, 1, 'droid developer', 'droiddev04@gmail.com', 'Zoneless change detection in Angular 20 is a total game-changer for performance! 🚀 By removing Zone.js, apps get smaller (~30KB lighter) and faster, with initial renders speeding up by 40-60% . Instead of monkey-patching browser APIs, Angular now relies on explicit triggers like Signals and markForCheck, meaning change detection only runs when it truly needs to . This eliminates unnecessary cycles and gives developers finer control over reactivity. Plus, debugging becomes way cleaner without Zone.js polluting stack traces . The path forward is clear: embrace Signals and the OnPush strategy to make your app future-proof . If you haven\'t experimented with provideZonelessChangeDetection() yet, Angular 20\'s Developer Preview is the perfect time to start .\n', 'published', '2026-02-17 12:09:57');

-- --------------------------------------------------------

--
-- Table structure for table `users`
--

CREATE TABLE `users` (
  `id` int(11) NOT NULL,
  `google_id` varchar(255) NOT NULL,
  `email` varchar(255) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `picture` text DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Dumping data for table `users`
--

INSERT INTO `users` (`id`, `google_id`, `email`, `name`, `picture`, `created_at`) VALUES
(1, '111048257207824222980', 'rahul@beyoiwellness.com', 'Rahul Prajapati', 'https://lh3.googleusercontent.com/a/ACg8ocL34xM7v-JWyJTkDBIykUQs7Z_U118WgsyU9oZH8bXVkzkuEg=s96-c', '2026-02-16 12:40:40'),
(2, '115082298373514061788', 'droiddev04@gmail.com', 'droid developer', 'https://lh3.googleusercontent.com/a/ACg8ocLyBN6RSaIY1dacHyL-wdlRa7dhH1qzqBgjTBsDSHOLesVLyQ=s96-c', '2026-02-17 11:59:29');

-- --------------------------------------------------------

--
-- Table structure for table `visitors`
--

CREATE TABLE `visitors` (
  `id` int(11) NOT NULL,
  `ip_address` varchar(45) DEFAULT NULL,
  `user_agent` text DEFAULT NULL,
  `page_visited` varchar(255) DEFAULT NULL,
  `visited_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;

--
-- Indexes for dumped tables
--

--
-- Indexes for table `admins`
--
ALTER TABLE `admins`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `username` (`username`);

--
-- Indexes for table `blogs`
--
ALTER TABLE `blogs`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `comments`
--
ALTER TABLE `comments`
  ADD PRIMARY KEY (`id`),
  ADD KEY `blog_id` (`blog_id`);

--
-- Indexes for table `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `google_id` (`google_id`);

--
-- Indexes for table `visitors`
--
ALTER TABLE `visitors`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `admins`
--
ALTER TABLE `admins`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `blogs`
--
ALTER TABLE `blogs`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT for table `comments`
--
ALTER TABLE `comments`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;

--
-- AUTO_INCREMENT for table `users`
--
ALTER TABLE `users`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=3;

--
-- AUTO_INCREMENT for table `visitors`
--
ALTER TABLE `visitors`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=44;

--
-- Constraints for dumped tables
--

--
-- Constraints for table `comments`
--
ALTER TABLE `comments`
  ADD CONSTRAINT `comments_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blogs` (`id`) ON DELETE CASCADE;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
